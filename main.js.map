{
  "version": 3,
  "sources": ["../node_modules/ripple/src/runtime/internal/client/constants.js", "../node_modules/ripple/src/runtime/internal/client/utils.js", "../node_modules/ripple/src/runtime/internal/client/operations.js", "../node_modules/ripple/src/utils/events.js", "../node_modules/esm-env/true.js", "../node_modules/ripple/src/runtime/internal/client/runtime.js", "../node_modules/ripple/src/runtime/internal/client/events.js", "../node_modules/clsx/dist/clsx.mjs", "../node_modules/ripple/src/utils/normalize_css_property_name.js", "../node_modules/ripple/src/runtime/internal/client/render.js", "../node_modules/ripple/src/runtime/internal/client/blocks.js", "../node_modules/ripple/src/runtime/internal/client/css.js", "../node_modules/ripple/src/runtime/proxy.js", "../node_modules/ripple/src/runtime/array.js", "../node_modules/ripple/src/runtime/set.js", "../node_modules/ripple/src/runtime/map.js", "../node_modules/ripple/src/runtime/date.js", "../node_modules/ripple/src/runtime/url-search-params.js", "../node_modules/ripple/src/runtime/url.js", "../node_modules/ripple/src/constants.js", "../node_modules/ripple/src/runtime/internal/client/for.js", "../node_modules/ripple/src/runtime/internal/client/template.js", "../node_modules/ripple/src/runtime/media-query.js", "../node_modules/ripple/src/runtime/internal/client/bindings.js", "../node_modules/ripple/src/runtime/index-client.js", "../src/lib/game.ts", "../src/lib/utils.ts", "../src/App.compiled.js", "../src/main.ts"],
  "sourcesContent": [
    "export var ROOT_BLOCK = 1 << 1;\nexport var RENDER_BLOCK = 1 << 2;\nexport var EFFECT_BLOCK = 1 << 3;\nexport var BRANCH_BLOCK = 1 << 4;\nexport var FOR_BLOCK = 1 << 5;\nexport var TRY_BLOCK = 1 << 6;\nexport var IF_BLOCK = 1 << 7;\nexport var SWITCH_BLOCK = 1 << 8;\nexport var COMPOSITE_BLOCK = 1 << 9;\nexport var ASYNC_BLOCK = 1 << 10;\nexport var HEAD_BLOCK = 1 << 11;\nexport var CONTAINS_UPDATE = 1 << 12;\nexport var CONTAINS_TEARDOWN = 1 << 13;\nexport var BLOCK_HAS_RUN = 1 << 14;\nexport var TRACKED = 1 << 15;\nexport var DERIVED = 1 << 16;\nexport var DEFERRED = 1 << 17;\nexport var PAUSED = 1 << 18;\nexport var DESTROYED = 1 << 19;\n\nexport var CONTROL_FLOW_BLOCK = FOR_BLOCK | IF_BLOCK | SWITCH_BLOCK | TRY_BLOCK | COMPOSITE_BLOCK;\n\nexport var UNINITIALIZED = Symbol();\n/** @type {unique symbol} */\nexport const TRACKED_ARRAY = Symbol();\n/** @type {unique symbol} */\nexport const TRACKED_OBJECT = Symbol();\nexport var COMPUTED_PROPERTY = Symbol();\nexport var REF_PROP = 'ref';\n/** @type {unique symbol} */\nexport const ARRAY_SET_INDEX_AT = Symbol();\nexport const MAX_ARRAY_LENGTH = 2 ** 32 - 1;\nexport const DEFAULT_NAMESPACE = 'html';\nexport const NAMESPACE_URI = {\n\thtml: 'http://www.w3.org/1999/xhtml',\n\tsvg: 'http://www.w3.org/2000/svg',\n\tmathml: 'http://www.w3.org/1998/Math/MathML',\n};\n",
    "/** @import { NAMESPACE_URI } from './constants.js' */\n\n/** @type {typeof Object.getOwnPropertyDescriptor} */\nexport var get_descriptor = Object.getOwnPropertyDescriptor;\n/** @type {typeof Object.getOwnPropertyDescriptors} */\nexport var get_descriptors = Object.getOwnPropertyDescriptors;\n/** @type {typeof Array.from} */\nexport var array_from = Array.from;\n/** @type {typeof Array.isArray} */\nexport var is_array = Array.isArray;\n/** @type {typeof Object.defineProperty} */\nexport var define_property = Object.defineProperty;\n/** @type {typeof Object.getPrototypeOf} */\nexport var get_prototype_of = Object.getPrototypeOf;\n/** @type {typeof Object.values} */\nexport var object_values = Object.values;\n/** @type {typeof Object.entries} */\nexport var object_entries = Object.entries;\n/** @type {typeof Object.keys} */\nexport var object_keys = Object.keys;\n/** @type {typeof Object.getOwnPropertySymbols} */\nexport var get_own_property_symbols = Object.getOwnPropertySymbols;\n/** @type {typeof structuredClone} */\nexport var structured_clone = structuredClone;\n/** @type {typeof Object.prototype} */\nexport var object_prototype = Object.prototype;\n/** @type {typeof Array.prototype} */\nexport var array_prototype = Array.prototype;\n\n/**\n * Creates a text node that serves as an anchor point in the DOM.\n * @returns {Text}\n */\nexport function create_anchor() {\n\tvar t = document.createTextNode('');\n\t/** @type {any} */ (t).__t = '';\n\treturn t;\n}\n\n/**\n * Checks if an object is a tracked object (has a numeric 'f' property).\n * @param {any} v - The object to check.\n * @returns {boolean}\n */\nexport function is_tracked_object(v) {\n\treturn typeof v === 'object' && v !== null && typeof (/** @type {any} */ (v).f) === 'number';\n}\n\n/**\n * Converts a tag name to its corresponding namespace.\n * @param {keyof SVGElementTagNameMap | keyof MathMLElementTagNameMap | keyof HTMLElementTagNameMap} element\n * @param {keyof typeof NAMESPACE_URI} current_namespace\n * @returns {keyof typeof NAMESPACE_URI}\n */\nexport function top_element_to_ns(element, current_namespace) {\n\tif (element === 'svg') {\n\t\treturn 'svg';\n\t} else if (element === 'math') {\n\t\treturn 'mathml';\n\t} else {\n\t\treturn current_namespace;\n\t}\n}\n",
    "import { get_descriptor } from './utils.js';\n\n/** @type {() => Node | null} */\nvar first_child_getter;\n/** @type {() => Node | null} */\nvar next_sibling_getter;\n\n/** @type {Document} */\nexport var document;\n\n/** @type {boolean} */\nexport var is_firefox;\n\nexport function init_operations() {\n\tvar node_prototype = Node.prototype;\n\tvar element_prototype = Element.prototype;\n\tvar event_target_prototype = EventTarget.prototype;\n\n\tis_firefox = /Firefox/.test(navigator.userAgent);\n\tdocument = window.document;\n\n\t// @ts-ignore\n\tfirst_child_getter = get_descriptor(node_prototype, 'firstChild').get;\n\t// @ts-ignore\n\tnext_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;\n\n\t// the following assignments improve perf of lookups on DOM nodes\n\t// @ts-expect-error\n\telement_prototype.__click = undefined;\n\t// @ts-expect-error\n\tevent_target_prototype.__root = undefined;\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\nexport function first_child(node) {\n\treturn first_child_getter.call(node);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\nexport function child_frag(node) {\n\tvar child = /** @type {Text} */ (first_child(node));\n\n\tif (child.nodeType === Node.COMMENT_NODE && child.data === '') {\n\t\treturn next_sibling(child);\n\t}\n\treturn child;\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function next_sibling(node) {\n\treturn next_sibling_getter.call(node);\n}\n\nexport function create_text(value = '') {\n\treturn document.createTextNode(value);\n}\n",
    "/** @import { AddEventObject } from '#public'*/\n\nconst NON_DELEGATED_EVENTS = new Set([\n\t'abort',\n\t'afterprint',\n\t'beforeprint',\n\t'beforetoggle',\n\t'beforeunload',\n\t'blur',\n\t'close',\n\t'command',\n\t'contextmenu',\n\t'cuechange',\n\t'DOMContentLoaded',\n\t'error',\n\t'focus',\n\t'invalid',\n\t'load',\n\t'loadend',\n\t'loadstart',\n\t'mouseenter',\n\t'mouseleave',\n\t'pointerenter',\n\t'pointerleave',\n\t'progress',\n\t'readystatechange',\n\t'resize',\n\t'scroll',\n\t'scrollend',\n\t'toggle',\n\t'unload',\n\t'visibilitychange',\n\t// Media Events\n\t'canplay',\n\t'canplaythrough',\n\t'durationchange',\n\t'emptied',\n\t'encrypted',\n\t'ended',\n\t'loadeddata',\n\t'loadedmetadata',\n\t'loadstart',\n\t'pause',\n\t'play',\n\t'playing',\n\t'progress',\n\t'ratechange',\n\t'seeked',\n\t'seeking',\n\t'stalled',\n\t'suspend',\n\t'timeupdate',\n\t'volumechange',\n\t'waiting',\n\t'waitingforkey',\n]);\n\n/**\n * Checks if an event should be delegated\n * @param {string} event_name - The event name (e.g., 'click', 'focus')\n * @returns {boolean}\n */\nexport function is_non_delegated(event_name) {\n\treturn NON_DELEGATED_EVENTS.has(event_name);\n}\n\n/**\n * Determines if an attribute is an event attribute (e.g., 'onClick').\n * @param {string} attr - The attribute name.\n * @returns {boolean}\n */\nexport function is_event_attribute(attr) {\n\treturn attr.startsWith('on') && attr.length > 2 && attr[2] === attr[2].toUpperCase();\n}\n\n/**\n * Checks if the event is a capture event.\n * @param {string} event_name - The event name.\n * @returns {boolean}\n */\nexport function is_capture_event(event_name) {\n\tvar lowered = event_name.toLowerCase();\n\treturn (\n\t\tevent_name.endsWith('Capture') &&\n\t\tlowered !== 'gotpointercapture' &&\n\t\tlowered !== 'lostpointercapture'\n\t);\n}\n\n/**\n * Retrieves the original event name from an event attribute.\n * @param {string} name\n * @returns {string}\n */\nexport function get_original_event_name(name) {\n\treturn name.slice(2);\n}\n\n/**\n * Normalizes the event name to lowercase.\n * @param {string} name\n * @returns {string}\n */\nexport function normalize_event_name(name) {\n\treturn extract_event_name(name).toLowerCase();\n}\n\n/**\n * Extracts the base event name from an event attribute.\n * @param {string} name\n * @returns {string}\n */\nfunction extract_event_name(name) {\n\tname = get_original_event_name(name);\n\n\tif (is_capture_event(name)) {\n\t\treturn event_name_from_capture(name);\n\t}\n\treturn name;\n}\n\n/**\n * Converts a capture event name to its base event name.\n * @param {string} event_name\n * @returns {string}\n */\nexport function event_name_from_capture(event_name) {\n\treturn event_name.slice(0, -7); // strip \"Capture\"\n}\n\n/**\n * Converts an event attribute name to the actual event name.\n * @param {string} name\n * @param {EventListener | AddEventObject} handler\n * @returns {string}\n */\nexport function get_attribute_event_name(name, handler) {\n\tname = extract_event_name(name);\n\n\treturn typeof handler === 'object' && handler.customName\n\t\t? handler.customName\n\t\t: name.toLowerCase();\n}\n\nconst PASSIVE_EVENTS = ['touchstart', 'touchmove', 'wheel', 'mousewheel'];\n\n/**\n * Checks if an event is passive (e.g., 'touchstart', 'touchmove').\n * @param {string} name - The event name.\n * @returns {boolean}\n */\nexport function is_passive_event(name) {\n\treturn PASSIVE_EVENTS.includes(name);\n}\n",
    "export default true;\n",
    "/** @import { Block, Component, Dependency, Derived, Tracked } from '#client' */\n/** @import { NAMESPACE_URI } from './constants.js' */\n\nimport { DEV } from 'esm-env';\nimport {\n\tdestroy_block,\n\tdestroy_non_branch_children,\n\teffect,\n\tis_destroyed,\n\trender,\n} from './blocks.js';\nimport {\n\tASYNC_BLOCK,\n\tBLOCK_HAS_RUN,\n\tBRANCH_BLOCK,\n\tDERIVED,\n\tCOMPUTED_PROPERTY,\n\tCONTAINS_TEARDOWN,\n\tCONTAINS_UPDATE,\n\tDEFERRED,\n\tDESTROYED,\n\tEFFECT_BLOCK,\n\tPAUSED,\n\tROOT_BLOCK,\n\tTRACKED,\n\tTRY_BLOCK,\n\tUNINITIALIZED,\n\tREF_PROP,\n\tTRACKED_OBJECT,\n\tDEFAULT_NAMESPACE,\n} from './constants.js';\nimport { capture, suspend } from './try.js';\nimport {\n\tdefine_property,\n\tget_descriptor,\n\tget_own_property_symbols,\n\tis_array,\n\tis_tracked_object,\n\tobject_keys,\n} from './utils.js';\n\nconst FLUSH_MICROTASK = 0;\nconst FLUSH_SYNC = 1;\n\n/** @type {null | Block} */\nexport let active_block = null;\n/** @type {null | Block | Derived} */\nexport let active_reaction = null;\n/** @type {null | Block} */\nexport let active_scope = null;\n/** @type {null | Component} */\nexport let active_component = null;\n/** @type {keyof typeof NAMESPACE_URI} */\nexport let active_namespace = DEFAULT_NAMESPACE;\n/** @type {boolean} */\nexport let is_mutating_allowed = true;\n\n/** @type {Map<Tracked, any>} */\nvar old_values = new Map();\n\n// Used for controlling the flush of blocks\n/** @type {number} */\nlet scheduler_mode = FLUSH_MICROTASK;\n// Used for handling scheduling\n/** @type {boolean} */\nlet is_micro_task_queued = false;\n/** @type {number} */\nlet clock = 0;\n/** @type {Block[]} */\nlet queued_root_blocks = [];\n/** @type {(() => void)[]} */\nlet queued_microtasks = [];\n/** @type {number} */\nlet flush_count = 0;\n/** @type {null | Dependency} */\nlet active_dependency = null;\n\nexport let tracking = false;\nexport let teardown = false;\n\n/**\n * @returns {number}\n */\nfunction increment_clock() {\n\treturn ++clock;\n}\n\n/**\n * @param {Block | null} block\n */\nexport function set_active_block(block) {\n\tactive_block = block;\n}\n\n/**\n * @param {Block | Derived | null} reaction\n */\nexport function set_active_reaction(reaction) {\n\tactive_reaction = reaction;\n}\n\n/**\n * @param {Component | null} component\n */\nexport function set_active_component(component) {\n\tactive_component = component;\n}\n\n/**\n * @param {boolean} value\n */\nexport function set_tracking(value) {\n\ttracking = value;\n}\n\n/**\n * @param {Block} block\n */\nexport function run_teardown(block) {\n\tvar fn = block.t;\n\tif (fn !== null) {\n\t\tvar previous_block = active_block;\n\t\tvar previous_reaction = active_reaction;\n\t\tvar previous_tracking = tracking;\n\t\tvar previous_teardown = teardown;\n\n\t\ttry {\n\t\t\tactive_block = null;\n\t\t\tactive_reaction = null;\n\t\t\ttracking = false;\n\t\t\tteardown = true;\n\t\t\tfn.call(null);\n\t\t} finally {\n\t\t\tactive_block = previous_block;\n\t\t\tactive_reaction = previous_reaction;\n\t\t\ttracking = previous_tracking;\n\t\t\tteardown = previous_teardown;\n\t\t}\n\t}\n}\n\n/**\n * @param {Block} block\n * @param {() => void} fn\n */\nexport function with_block(block, fn) {\n\tvar prev_block = active_block;\n\tvar previous_component = active_component;\n\tactive_block = block;\n\tactive_component = block.co;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tactive_component = previous_component;\n\t\tactive_block = prev_block;\n\t}\n}\n\n/**\n * @param {Derived} computed\n */\nfunction update_derived(computed) {\n\tvar value = computed.__v;\n\n\tif (value === UNINITIALIZED || is_tracking_dirty(computed.d)) {\n\t\tvalue = run_derived(computed);\n\n\t\tif (value !== computed.__v) {\n\t\t\tcomputed.__v = value;\n\t\t\tcomputed.c = increment_clock();\n\t\t}\n\t}\n}\n\n/**\n * @param {Derived} computed\n */\nfunction destroy_computed_children(computed) {\n\tvar blocks = computed.blocks;\n\n\tif (blocks !== null) {\n\t\tcomputed.blocks = null;\n\t\tfor (var i = 0; i < blocks.length; i++) {\n\t\t\tdestroy_block(blocks[i]);\n\t\t}\n\t}\n}\n\n/**\n * @param {Derived} computed\n */\nfunction run_derived(computed) {\n\tvar previous_block = active_block;\n\tvar previous_reaction = active_reaction;\n\tvar previous_tracking = tracking;\n\tvar previous_dependency = active_dependency;\n\tvar previous_component = active_component;\n\tvar previous_is_mutating_allowed = is_mutating_allowed;\n\n\ttry {\n\t\tactive_block = computed.b;\n\t\tactive_reaction = computed;\n\t\ttracking = true;\n\t\tactive_dependency = null;\n\t\tactive_component = computed.co;\n\t\tis_mutating_allowed = false;\n\n\t\tdestroy_computed_children(computed);\n\n\t\tvar value = computed.fn();\n\n\t\tcomputed.d = active_dependency;\n\n\t\treturn value;\n\t} finally {\n\t\tactive_block = previous_block;\n\t\tactive_reaction = previous_reaction;\n\t\ttracking = previous_tracking;\n\t\tactive_dependency = previous_dependency;\n\t\tactive_component = previous_component;\n\t\tis_mutating_allowed = previous_is_mutating_allowed;\n\t}\n}\n\n/**\n * @param {unknown} error\n * @param {Block} block\n */\nexport function handle_error(error, block) {\n\t/** @type {Block | null} */\n\tvar current = block;\n\n\twhile (current !== null) {\n\t\tvar state = current.s;\n\t\tif ((current.f & TRY_BLOCK) !== 0 && state.c !== null) {\n\t\t\tstate.c(error);\n\t\t\treturn;\n\t\t}\n\t\tcurrent = current.p;\n\t}\n\n\tthrow error;\n}\n\n/**\n * @param {Block} block\n */\nexport function run_block(block) {\n\tvar previous_block = active_block;\n\tvar previous_reaction = active_reaction;\n\tvar previous_tracking = tracking;\n\tvar previous_dependency = active_dependency;\n\tvar previous_component = active_component;\n\n\ttry {\n\t\tactive_block = block;\n\t\tactive_reaction = block;\n\t\tactive_component = block.co;\n\n\t\tdestroy_non_branch_children(block);\n\t\trun_teardown(block);\n\n\t\ttracking = (block.f & (ROOT_BLOCK | BRANCH_BLOCK)) === 0;\n\t\tactive_dependency = null;\n\t\tvar res = block.fn(block.s);\n\n\t\tif (typeof res === 'function') {\n\t\t\tblock.t = res;\n\t\t\t/** @type {Block | null} */\n\t\t\tlet current = block;\n\n\t\t\twhile (current !== null && (current.f & CONTAINS_TEARDOWN) === 0) {\n\t\t\t\tcurrent.f ^= CONTAINS_TEARDOWN;\n\t\t\t\tcurrent = current.p;\n\t\t\t}\n\t\t}\n\n\t\tblock.d = active_dependency;\n\t} catch (error) {\n\t\thandle_error(error, block);\n\t} finally {\n\t\tactive_block = previous_block;\n\t\tactive_reaction = previous_reaction;\n\t\ttracking = previous_tracking;\n\t\tactive_dependency = previous_dependency;\n\t\tactive_component = previous_component;\n\t}\n}\n\nvar empty_get_set = { get: undefined, set: undefined };\n\n/**\n *\n * @param {any} v\n * @param {Block} block\n * @param {(value: any) => any} [get]\n * @param {(next: any, prev: any) => any} [set]\n * @returns {Tracked}\n */\nexport function tracked(v, block, get, set) {\n\t// TODO: now we expose tracked, we should likely block access in DEV somehow\n\tif (DEV) {\n\t\treturn {\n\t\t\tDO_NOT_ACCESS_THIS_OBJECT_DIRECTLY: true,\n\t\t\ta: get || set ? { get, set } : empty_get_set,\n\t\t\tb: block || active_block,\n\t\t\tc: 0,\n\t\t\tf: TRACKED,\n\t\t\t__v: v,\n\t\t};\n\t}\n\n\treturn {\n\t\ta: get || set ? { get, set } : empty_get_set,\n\t\tb: block || active_block,\n\t\tc: 0,\n\t\tf: TRACKED,\n\t\t__v: v,\n\t};\n}\n\n/**\n * @param {any} fn\n * @param {any} block\n * @param {(value: any) => any} [get]\n * @param {(next: any, prev: any) => any} [set]\n * @returns {Derived}\n */\nexport function derived(fn, block, get, set) {\n\tif (DEV) {\n\t\treturn {\n\t\t\tDO_NOT_ACCESS_THIS_OBJECT_DIRECTLY: true,\n\t\t\ta: get || set ? { get, set } : empty_get_set,\n\t\t\tb: block || active_block,\n\t\t\tblocks: null,\n\t\t\tc: 0,\n\t\t\tco: active_component,\n\t\t\td: null,\n\t\t\tf: TRACKED | DERIVED,\n\t\t\tfn,\n\t\t\t__v: UNINITIALIZED,\n\t\t};\n\t}\n\n\treturn {\n\t\ta: get || set ? { get, set } : empty_get_set,\n\t\tb: block || active_block,\n\t\tblocks: null,\n\t\tc: 0,\n\t\tco: active_component,\n\t\td: null,\n\t\tf: TRACKED | DERIVED,\n\t\tfn,\n\t\t__v: UNINITIALIZED,\n\t};\n}\n\n/**\n * @param {any} v\n * @param {(value: any) => any | undefined} get\n * @param {(next: any, prev: any) => any | undefined} set\n * @param {Block} b\n * @returns {Tracked | Derived}\n */\nexport function track(v, get, set, b) {\n\tif (is_tracked_object(v)) {\n\t\treturn v;\n\t}\n\tif (b === null) {\n\t\tthrow new TypeError('track() requires a valid component context');\n\t}\n\n\tif (typeof v === 'function') {\n\t\treturn derived(v, b, get, set);\n\t}\n\treturn tracked(v, b, get, set);\n}\n\n/**\n * @param {Record<string|symbol, any>} v\n * @param {(symbol | string)[]} l\n * @param {Block} b\n * @returns {Tracked[]}\n */\nexport function track_split(v, l, b) {\n\tvar is_tracked = is_tracked_object(v);\n\n\tif (is_tracked || typeof v !== 'object' || v === null || is_array(v)) {\n\t\tthrow new TypeError('Invalid value: expected a non-tracked object');\n\t}\n\n\t/** @type {Tracked[]} */\n\tvar out = [];\n\t/** @type {Record<string|symbol, any>} */\n\tvar rest = {};\n\t/** @type {Record<PropertyKey, 1>} */\n\tvar done = {};\n\tvar props = Reflect.ownKeys(v);\n\n\tfor (let i = 0, key, t; i < l.length; i++) {\n\t\tkey = l[i];\n\n\t\tif (props.includes(key)) {\n\t\t\tif (is_tracked_object(v[key])) {\n\t\t\t\tt = v[key];\n\t\t\t} else {\n\t\t\t\tt = tracked(undefined, b);\n\t\t\t\tt = define_property(t, '__v', /** @type {PropertyDescriptor} */ (get_descriptor(v, key)));\n\t\t\t}\n\t\t} else {\n\t\t\tt = tracked(undefined, b);\n\t\t}\n\n\t\tout[i] = t;\n\t\tdone[key] = 1;\n\t}\n\n\tfor (let i = 0, key; i < props.length; i++) {\n\t\tkey = props[i];\n\t\tif (done[key]) {\n\t\t\tcontinue;\n\t\t}\n\t\tdefine_property(rest, key, /** @type {PropertyDescriptor} */ (get_descriptor(v, key)));\n\t}\n\n\tout.push(tracked(rest, b));\n\n\treturn out;\n}\n\n/**\n * @param {Tracked | Derived} tracked\n * @returns {Dependency}\n */\nfunction create_dependency(tracked) {\n\tvar reaction = /** @type {Derived | Block} **/ (active_reaction);\n\tvar existing = reaction.d;\n\n\t// Recycle tracking entries\n\tif (existing !== null) {\n\t\treaction.d = existing.n;\n\t\texisting.c = tracked.c;\n\t\texisting.t = tracked;\n\t\texisting.n = null;\n\t\treturn existing;\n\t}\n\n\treturn {\n\t\tc: tracked.c,\n\t\tt: tracked,\n\t\tn: null,\n\t};\n}\n\n/**\n * @param {Dependency | null} tracking\n */\nfunction is_tracking_dirty(tracking) {\n\tif (tracking === null) {\n\t\treturn false;\n\t}\n\twhile (tracking !== null) {\n\t\tvar tracked = tracking.t;\n\n\t\tif ((tracked.f & DERIVED) !== 0) {\n\t\t\tupdate_derived(/** @type {Derived} **/ (tracked));\n\t\t}\n\n\t\tif (tracked.c > tracking.c) {\n\t\t\treturn true;\n\t\t}\n\t\ttracking = tracking.n;\n\t}\n\n\treturn false;\n}\n\n/**\n * @param {Block} block\n */\nexport function is_block_dirty(block) {\n\tvar flags = block.f;\n\n\tif ((flags & (ROOT_BLOCK | BRANCH_BLOCK)) !== 0) {\n\t\treturn false;\n\t}\n\tif ((flags & BLOCK_HAS_RUN) === 0) {\n\t\tblock.f ^= BLOCK_HAS_RUN;\n\t\treturn true;\n\t}\n\n\treturn is_tracking_dirty(block.d);\n}\n\n/**\n * @param {() => Promise<any>} fn\n * @param {Block} block\n * @returns {Promise<Tracked>}\n */\nexport function async_computed(fn, block) {\n\t/** @type {Block | Derived | null} */\n\tlet parent = active_reaction;\n\tvar t = tracked(UNINITIALIZED, block);\n\t/** @type {Promise<any>} */\n\tvar promise;\n\t/** @type {Map<Tracked, {v: any, c: number}>} */\n\tvar new_values = new Map();\n\n\trender(\n\t\t() => {\n\t\t\tvar [current, deferred] = capture_deferred(() => (promise = fn()));\n\n\t\t\tvar restore = capture();\n\t\t\t/** @type {(() => void) | undefined} */\n\t\t\tvar unsuspend;\n\n\t\t\tif (deferred === null) {\n\t\t\t\tunsuspend = suspend();\n\t\t\t} else {\n\t\t\t\tfor (var i = 0; i < deferred.length; i++) {\n\t\t\t\t\tvar tracked = deferred[i];\n\t\t\t\t\tnew_values.set(tracked, { v: tracked.__v, c: tracked.c });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpromise.then((v) => {\n\t\t\t\tif (parent && is_destroyed(/** @type {Block} */ (parent))) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (promise === current && t.__v !== v) {\n\t\t\t\t\trestore();\n\n\t\t\t\t\tif (t.__v === UNINITIALIZED) {\n\t\t\t\t\t\tt.__v = v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tset(t, v);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (deferred === null) {\n\t\t\t\t\tunsuspend?.();\n\t\t\t\t} else if (promise === current) {\n\t\t\t\t\tfor (var i = 0; i < deferred.length; i++) {\n\t\t\t\t\t\tvar tracked = deferred[i];\n\t\t\t\t\t\tvar stored = /** @type {{ v: any, c: number }} */ (new_values.get(tracked));\n\t\t\t\t\t\tvar { v, c } = stored;\n\t\t\t\t\t\ttracked.__v = v;\n\t\t\t\t\t\ttracked.c = c;\n\t\t\t\t\t\tschedule_update(tracked.b);\n\t\t\t\t\t}\n\t\t\t\t\tnew_values.clear();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tnull,\n\t\tASYNC_BLOCK,\n\t);\n\n\treturn new Promise(async (resolve) => {\n\t\tvar p;\n\t\twhile (p !== (p = promise)) await p;\n\t\treturn resolve(t);\n\t});\n}\n\n/**\n * @template V\n * @param {Function} fn\n * @param {V} v\n */\nfunction trigger_track_get(fn, v) {\n\tvar previous_is_mutating_allowed = is_mutating_allowed;\n\ttry {\n\t\tis_mutating_allowed = false;\n\t\treturn untrack(() => fn(v));\n\t} finally {\n\t\tis_mutating_allowed = previous_is_mutating_allowed;\n\t}\n}\n\n/**\n * @param {() => any} fn\n * @returns {[any, Tracked[] | null]}\n */\nfunction capture_deferred(fn) {\n\tvar value = fn();\n\t/** @type {Tracked[] | null} */\n\tvar deferred = null;\n\tvar dependency = active_dependency;\n\n\twhile (dependency !== null) {\n\t\tvar tracked = dependency.t;\n\t\tif ((tracked.f & DEFERRED) !== 0) {\n\t\t\tdeferred ??= [];\n\t\t\tdeferred.push(tracked);\n\t\t\tbreak;\n\t\t}\n\t\tdependency = dependency.n;\n\t}\n\n\treturn [value, deferred];\n}\n\n/**\n * @param {Block} root_block\n */\nfunction flush_updates(root_block) {\n\t/** @type {Block | null} */\n\tvar current = root_block;\n\tvar containing_update = null;\n\tvar effects = [];\n\n\twhile (current !== null) {\n\t\tvar flags = current.f;\n\n\t\tif ((flags & CONTAINS_UPDATE) !== 0) {\n\t\t\tcurrent.f ^= CONTAINS_UPDATE;\n\t\t\tcontaining_update = current;\n\t\t}\n\n\t\tif ((flags & PAUSED) === 0 && containing_update !== null) {\n\t\t\tif ((flags & EFFECT_BLOCK) !== 0) {\n\t\t\t\teffects.push(current);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tif (is_block_dirty(current)) {\n\t\t\t\t\t\trun_block(current);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\thandle_error(error, current);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/** @type {Block | null} */\n\t\t\tvar child = current.first;\n\n\t\t\tif (child !== null) {\n\t\t\t\tcurrent = child;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/** @type {Block | null} */\n\t\tvar parent = current.p;\n\t\tcurrent = current.next;\n\n\t\twhile (current === null && parent !== null) {\n\t\t\tif (parent === containing_update) {\n\t\t\t\tcontaining_update = null;\n\t\t\t}\n\t\t\tcurrent = parent.next;\n\t\t\tparent = parent.p;\n\t\t}\n\t}\n\n\tvar length = effects.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar effect = effects[i];\n\t\tvar flags = effect.f;\n\n\t\ttry {\n\t\t\tif ((flags & (PAUSED | DESTROYED)) === 0 && is_block_dirty(effect)) {\n\t\t\t\trun_block(effect);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\thandle_error(error, effect);\n\t\t}\n\t}\n}\n\n/**\n * @param {Block[]} root_blocks\n */\nfunction flush_queued_root_blocks(root_blocks) {\n\tfor (let i = 0; i < root_blocks.length; i++) {\n\t\tflush_updates(root_blocks[i]);\n\t}\n}\n\n/**\n * @returns {Promise<void>}\n */\nexport async function tick() {\n\treturn new Promise((f) => requestAnimationFrame(() => f()));\n}\n\n/**\n * @returns {void}\n */\nfunction flush_microtasks() {\n\tis_micro_task_queued = false;\n\n\tif (queued_microtasks.length > 0) {\n\t\tvar microtasks = queued_microtasks;\n\t\tqueued_microtasks = [];\n\t\tfor (var i = 0; i < microtasks.length; i++) {\n\t\t\tmicrotasks[i]();\n\t\t}\n\t}\n\n\tif (flush_count > 1001) {\n\t\treturn;\n\t}\n\tvar previous_queued_root_blocks = queued_root_blocks;\n\tqueued_root_blocks = [];\n\tflush_queued_root_blocks(previous_queued_root_blocks);\n\n\tif (!is_micro_task_queued) {\n\t\tflush_count = 0;\n\t}\n\told_values.clear();\n}\n\n/**\n * @param { (() => void) } [fn]\n */\nexport function queue_microtask(fn) {\n\tif (!is_micro_task_queued) {\n\t\tis_micro_task_queued = true;\n\t\tqueueMicrotask(flush_microtasks);\n\t}\n\tif (fn !== undefined) {\n\t\tqueued_microtasks.push(fn);\n\t}\n}\n\n/**\n * @param {Block} block\n */\nexport function schedule_update(block) {\n\tif (scheduler_mode === FLUSH_MICROTASK) {\n\t\tqueue_microtask();\n\t}\n\tlet current = block;\n\n\twhile (current !== null) {\n\t\tvar flags = current.f;\n\t\tif ((flags & CONTAINS_UPDATE) !== 0) return;\n\t\tcurrent.f ^= CONTAINS_UPDATE;\n\t\tif ((flags & ROOT_BLOCK) !== 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = /** @type {Block} */ (current.p);\n\t}\n\n\tqueued_root_blocks.push(current);\n}\n\n/**\n * @param {Tracked} tracked\n */\nfunction register_dependency(tracked) {\n\tvar dependency = active_dependency;\n\n\tif (dependency === null) {\n\t\tdependency = create_dependency(tracked);\n\t\tactive_dependency = dependency;\n\t} else {\n\t\tvar current = dependency;\n\n\t\twhile (current !== null) {\n\t\t\tif (current.t === tracked) {\n\t\t\t\tcurrent.c = tracked.c;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar next = current.n;\n\t\t\tif (next === null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent = next;\n\t\t}\n\n\t\tdependency = create_dependency(tracked);\n\t\tcurrent.n = dependency;\n\t}\n}\n\n/**\n * @param {Derived} computed\n */\nexport function get_derived(computed) {\n\tupdate_derived(computed);\n\tif (tracking) {\n\t\tregister_dependency(computed);\n\t}\n\tvar get = computed.a.get;\n\tif (get !== undefined) {\n\t\tcomputed.__v = trigger_track_get(get, computed.__v);\n\t}\n\n\treturn computed.__v;\n}\n\n/**\n * @param {Derived | Tracked} tracked\n */\nexport function get(tracked) {\n\t// reflect back the value if it's not boxed\n\tif (!is_tracked_object(tracked)) {\n\t\treturn tracked;\n\t}\n\n\treturn (tracked.f & DERIVED) !== 0\n\t\t? get_derived(/** @type {Derived} */ (tracked))\n\t\t: get_tracked(tracked);\n}\n\n/**\n * @param {Tracked} tracked\n */\nexport function get_tracked(tracked) {\n\tvar value = tracked.__v;\n\tif (tracking) {\n\t\tregister_dependency(tracked);\n\t}\n\tif (teardown && old_values.has(tracked)) {\n\t\tvalue = old_values.get(tracked);\n\t}\n\tvar get = tracked.a.get;\n\tif (get !== undefined) {\n\t\tvalue = trigger_track_get(get, value);\n\t}\n\treturn value;\n}\n\n/**\n * Exposed version of `set` to avoid internal bugs\n * since block is required on the internal `set`\n * @param {Derived | Tracked} tracked\n * @param {any} value\n */\nexport function public_set(tracked, value) {\n\tset(tracked, value);\n}\n\n/**\n * @param {Derived | Tracked} tracked\n * @param {any} value\n */\nexport function set(tracked, value) {\n\tif (!is_mutating_allowed) {\n\t\tthrow new Error(\n\t\t\t'Assignments or updates to tracked values are not allowed during computed \"track(() => ...)\" evaluation',\n\t\t);\n\t}\n\n\tvar old_value = tracked.__v;\n\n\tif (value !== old_value) {\n\t\tvar tracked_block = tracked.b;\n\n\t\tif ((tracked_block.f & CONTAINS_TEARDOWN) !== 0) {\n\t\t\tif (teardown) {\n\t\t\t\told_values.set(tracked, value);\n\t\t\t} else {\n\t\t\t\told_values.set(tracked, old_value);\n\t\t\t}\n\t\t}\n\n\t\tlet set = tracked.a.set;\n\t\tif (set !== undefined) {\n\t\t\tvalue = untrack(() => set(value, old_value));\n\t\t}\n\n\t\ttracked.__v = value;\n\t\ttracked.c = increment_clock();\n\t\tschedule_update(tracked_block);\n\t}\n}\n\n/**\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nexport function untrack(fn) {\n\tvar previous_tracking = tracking;\n\tvar previous_dependency = active_dependency;\n\ttracking = false;\n\tactive_dependency = null;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\ttracking = previous_tracking;\n\t\tactive_dependency = previous_dependency;\n\t}\n}\n\n/**\n * @template T\n * @param {() => T} [fn]\n * @returns {T}\n */\nexport function flush_sync(fn) {\n\tvar previous_scheduler_mode = scheduler_mode;\n\tvar previous_queued_root_blocks = queued_root_blocks;\n\n\ttry {\n\t\t/** @type {Block[]} */\n\t\tvar root_blocks = [];\n\n\t\tscheduler_mode = FLUSH_SYNC;\n\t\tqueued_root_blocks = root_blocks;\n\t\tis_micro_task_queued = false;\n\n\t\tflush_queued_root_blocks(previous_queued_root_blocks);\n\n\t\tvar result = fn?.();\n\n\t\tif (queued_root_blocks.length > 0 || root_blocks.length > 0) {\n\t\t\tflush_sync();\n\t\t}\n\n\t\tflush_count = 0;\n\n\t\treturn /** @type {T} */ (result);\n\t} finally {\n\t\tscheduler_mode = previous_scheduler_mode;\n\t\tqueued_root_blocks = previous_queued_root_blocks;\n\t}\n}\n\n/**\n * @param {() => Object} fn\n * @returns {Object}\n */\nexport function spread_props(fn) {\n\treturn proxy_props(fn);\n}\n\n/**\n * @param {() => Object} fn\n * @returns {Object}\n */\nexport function proxy_props(fn) {\n\tconst memo = derived(fn, active_block);\n\n\treturn new Proxy(\n\t\t{},\n\t\t{\n\t\t\tget(_, property) {\n\t\t\t\t/** @type {Record<string | symbol, any> | Record<string | symbol, any>[]} */\n\t\t\t\tvar obj = get_derived(memo);\n\n\t\t\t\t// Handle array of objects/spreads (for multiple props)\n\t\t\t\tif (is_array(obj)) {\n\t\t\t\t\t// Search in reverse order (right-to-left) since later props override earlier ones\n\t\t\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\t\t\tvar item;\n\t\t\t\t\tfor (var i = obj.length - 1; i >= 0; i--) {\n\t\t\t\t\t\titem = obj[i];\n\t\t\t\t\t\tif (property in item) {\n\t\t\t\t\t\t\treturn item[property];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// Single object case\n\t\t\t\treturn obj[property];\n\t\t\t},\n\t\t\thas(_, property) {\n\t\t\t\tif (property === TRACKED_OBJECT) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t/** @type {Record<string | symbol, any> | Record<string | symbol, any>[]} */\n\t\t\t\tvar obj = get_derived(memo);\n\n\t\t\t\t// Handle array of objects/spreads\n\t\t\t\tif (is_array(obj)) {\n\t\t\t\t\tfor (var i = obj.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tif (property in obj[i]) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn property in obj;\n\t\t\t},\n\t\t\tgetOwnPropertyDescriptor(_, key) {\n\t\t\t\t/** @type {Record<string | symbol, any> | Record<string | symbol, any>[]} */\n\t\t\t\tvar obj = get_derived(memo);\n\n\t\t\t\t// Handle array of objects/spreads\n\t\t\t\tif (is_array(obj)) {\n\t\t\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\t\t\tvar item;\n\t\t\t\t\tfor (var i = obj.length - 1; i >= 0; i--) {\n\t\t\t\t\t\titem = obj[i];\n\t\t\t\t\t\tif (key in item) {\n\t\t\t\t\t\t\treturn get_descriptor(item, key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tif (key in obj) {\n\t\t\t\t\treturn get_descriptor(obj, key);\n\t\t\t\t}\n\t\t\t},\n\t\t\townKeys() {\n\t\t\t\t/** @type {Record<string | symbol, any> | Record<string | symbol, any>[]} */\n\t\t\t\tvar obj = get_derived(memo);\n\t\t\t\t/** @type {Record<string | symbol, 1>} */\n\t\t\t\tvar done = {};\n\t\t\t\t/** @type {(string | symbol)[]} */\n\t\t\t\tvar keys = [];\n\n\t\t\t\t// Handle array of objects/spreads\n\t\t\t\tif (is_array(obj)) {\n\t\t\t\t\t// Collect all keys from all objects, order doesn't matter\n\t\t\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\t\t\tvar item;\n\t\t\t\t\tfor (var i = 0; i < obj.length; i++) {\n\t\t\t\t\t\titem = obj[i];\n\t\t\t\t\t\tfor (const key of Reflect.ownKeys(item)) {\n\t\t\t\t\t\t\tif (done[key]) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdone[key] = 1;\n\t\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn keys;\n\t\t\t\t}\n\n\t\t\t\treturn Reflect.ownKeys(obj);\n\t\t\t},\n\t\t},\n\t);\n}\n\n/**\n * @template T\n * @param {() => T} fn\n * @returns {() => T}\n */\nexport function computed_property(fn) {\n\tdefine_property(fn, COMPUTED_PROPERTY, {\n\t\tvalue: true,\n\t\tenumerable: false,\n\t});\n\treturn fn;\n}\n\n/**\n * @param {any} obj\n * @param {string | number | symbol} property\n * @param {boolean} chain_obj\n * @param {boolean} chain_prop\n * @param {...any} args\n * @returns {any}\n */\nexport function call_property(obj, property, chain_obj, chain_prop, ...args) {\n\t// don't swallow errors if either the object or property is nullish,\n\t// respect optional chaining as provided\n\tif (!chain_obj && !chain_prop) {\n\t\treturn obj[property].call(obj, ...args);\n\t} else if (chain_obj && chain_prop) {\n\t\treturn obj?.[property]?.call(obj, ...args);\n\t} else if (chain_obj) {\n\t\treturn obj?.[property].call(obj, ...args);\n\t} else if (chain_prop) {\n\t\treturn obj[property]?.call(obj, ...args);\n\t}\n}\n\n/**\n * @param {any} obj\n * @param {string | number | symbol} property\n * @param {boolean} [chain=false]\n * @returns {any}\n */\nexport function get_property(obj, property, chain = false) {\n\tif (chain && obj == null) {\n\t\treturn undefined;\n\t}\n\tvar tracked = obj[property];\n\tif (tracked == null) {\n\t\treturn tracked;\n\t}\n\treturn get(tracked);\n}\n\n/**\n * @param {any} obj\n * @param {string | number | symbol} property\n * @param {any} value\n * @returns {void}\n */\nexport function set_property(obj, property, value) {\n\tvar tracked = obj[property];\n\tset(tracked, value);\n}\n\n/**\n * @param {Tracked} tracked\n * @param {number} [d]\n * @returns {number}\n */\nexport function update(tracked, d = 1) {\n\tvar value = get(tracked);\n\tvar result = d === 1 ? value++ : value--;\n\tset(tracked, value);\n\treturn result;\n}\n\n/**\n * @param {Tracked} tracked\n * @returns {void}\n */\nexport function increment(tracked) {\n\tset(tracked, tracked.__v + 1);\n}\n\n/**\n * @param {Tracked} tracked\n * @returns {void}\n */\nexport function decrement(tracked) {\n\tset(tracked, tracked.__v - 1);\n}\n\n/**\n * @param {Tracked} tracked\n * @param {number} [d]\n * @returns {number}\n */\nexport function update_pre(tracked, d = 1) {\n\tvar value = get(tracked);\n\tvar new_value = d === 1 ? ++value : --value;\n\tset(tracked, new_value);\n\treturn new_value;\n}\n\n/**\n * @param {any} obj\n * @param {string | number | symbol} property\n * @param {number} [d=1]\n * @returns {number}\n */\nexport function update_property(obj, property, d = 1) {\n\tvar tracked = obj[property];\n\tvar value = get(tracked);\n\tvar new_value = d === 1 ? value++ : value--;\n\tset(tracked, value);\n\treturn new_value;\n}\n\n/**\n * @param {any} obj\n * @param {string | number | symbol} property\n * @param {number} [d=1]\n * @returns {number}\n */\nexport function update_pre_property(obj, property, d = 1) {\n\tvar tracked = obj[property];\n\tvar value = get(tracked);\n\tvar new_value = d === 1 ? ++value : --value;\n\tset(tracked, new_value);\n\treturn new_value;\n}\n\n/**\n * @template T\n * @param {Block} block\n * @param {() => T} fn\n * @returns {T}\n */\nexport function with_scope(block, fn) {\n\tvar previous_scope = active_scope;\n\ttry {\n\t\tactive_scope = block;\n\t\treturn fn();\n\t} finally {\n\t\tactive_scope = previous_scope;\n\t}\n}\n\n/**\n * @returns {Block | null}\n */\nexport function scope() {\n\treturn active_scope || active_block;\n}\n\n/**\n * @param {string} [err]\n * @returns {Block | never}\n */\nexport function safe_scope(err = 'Cannot access outside of a component context') {\n\tif (active_scope === null) {\n\t\tthrow new Error(err);\n\t}\n\n\treturn /** @type {Block} */ (active_scope);\n}\n\nexport function create_component_ctx() {\n\treturn {\n\t\tc: null,\n\t\te: null,\n\t\tm: false,\n\t\tp: active_component,\n\t};\n}\n\n/**\n * @returns {void}\n */\nexport function push_component() {\n\tvar component = create_component_ctx();\n\tactive_component = component;\n}\n\n/**\n * @returns {void}\n */\nexport function pop_component() {\n\tvar component = /** @type {Component} */ (active_component);\n\tcomponent.m = true;\n\tvar effects = component.e;\n\tif (effects !== null) {\n\t\tvar length = effects.length;\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar { b: block, fn, r: reaction } = effects[i];\n\t\t\tvar previous_block = active_block;\n\t\t\tvar previous_reaction = active_reaction;\n\n\t\t\ttry {\n\t\t\t\tactive_block = block;\n\t\t\t\tactive_reaction = reaction;\n\t\t\t\teffect(fn);\n\t\t\t} finally {\n\t\t\t\tactive_block = previous_block;\n\t\t\t\tactive_reaction = previous_reaction;\n\t\t\t}\n\t\t}\n\t}\n\tactive_component = component.p;\n}\n\n/**\n * @template T\n * @param {() => T} fn\n * @param {keyof typeof NAMESPACE_URI} namespace\n * @returns {T}\n */\nexport function with_ns(namespace, fn) {\n\tvar previous_namespace = active_namespace;\n\tactive_namespace = namespace;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tactive_namespace = previous_namespace;\n\t}\n}\n\n/**\n * @returns {symbol}\n */\nexport function ref_prop() {\n\treturn Symbol(REF_PROP);\n}\n\n/**\n * @template T\n * @param {T | undefined} value\n * @param {T} fallback\n * @returns {T}\n */\nexport function fallback(value, fallback) {\n\treturn value === undefined ? fallback : value;\n}\n\n/**\n * @param {Record<string | symbol, unknown>} obj\n * @param {string[]} exclude_keys\n * @returns {Record<string | symbol, unknown>}\n */\nexport function exclude_from_object(obj, exclude_keys) {\n\tvar keys = object_keys(obj);\n\t/** @type {Record<string | symbol, unknown>} */\n\tvar new_obj = {};\n\n\tfor (const key of keys) {\n\t\tif (!exclude_keys.includes(key)) {\n\t\t\tnew_obj[key] = obj[key];\n\t\t}\n\t}\n\n\tfor (const symbol of get_own_property_symbols(obj)) {\n\t\tvar ref_fn = obj[symbol];\n\n\t\tif (symbol.description === REF_PROP) {\n\t\t\tnew_obj[symbol] = ref_fn;\n\t\t}\n\t}\n\n\treturn new_obj;\n}\n\n/**\n * @param {any} v\n * @returns {Promise<() => any>}\n */\nexport async function maybe_tracked(v) {\n\tvar restore = capture();\n\tlet value;\n\n\tif (is_tracked_object(v)) {\n\t\tif ((v.f & DERIVED) !== 0) {\n\t\t\tvalue = await async_computed(v.fn, v.b);\n\t\t} else {\n\t\t\tvalue = await async_computed(async () => {\n\t\t\t\treturn await get_tracked(v);\n\t\t\t}, /** @type {Block} */ (active_block));\n\t\t}\n\t} else {\n\t\tvalue = await v;\n\t}\n\n\treturn () => {\n\t\trestore();\n\t\treturn value;\n\t};\n}\n",
    "/** @import { AddEventObject, AddEventOptions, ExtendedEventOptions } from '#public'*/\n/**\n * @typedef {EventTarget & Record<string, any>} DelegatedEventTarget\n */\nimport {\n\tevent_name_from_capture,\n\tis_capture_event,\n\tis_non_delegated,\n\tis_passive_event,\n} from '../../../utils/events.js';\nimport {\n\tactive_block,\n\tactive_reaction,\n\tset_active_block,\n\tset_active_reaction,\n\tset_tracking,\n\ttracking,\n} from './runtime.js';\nimport { array_from, define_property, is_array } from './utils.js';\nimport { render } from './blocks.js';\n\n/** @type {Set<string>} */\nvar all_registered_events = new Set();\n\n/** @type {Set<(events: Array<string>) => void>} */\nvar root_event_handles = new Set();\n\n/** @type {Element | null} */\nvar root_target = null;\n\n/**\n * @param {AddEventOptions} options\n * @returns {AddEventListenerOptions}\n */\nfunction get_event_options(options) {\n\t/** @type AddEventListenerOptions */\n\tvar event_options = {};\n\n\tif (options.capture) {\n\t\tevent_options.capture = true;\n\t}\n\tif (options.once) {\n\t\tevent_options.once = true;\n\t}\n\tif (options.passive) {\n\t\tevent_options.passive = true;\n\t}\n\tif (options.signal) {\n\t\tevent_options.signal = options.signal;\n\t}\n\treturn event_options;\n}\n\n/**\n * @param {EventTarget} element\n * @param {string} type\n * @param {EventListener} handler\n * @param {ExtendedEventOptions} [options]\n */\nexport function on(element, type, handler, options = {}) {\n\tvar opts = { ...options };\n\tif (\n\t\telement === window ||\n\t\telement === document ||\n\t\telement === document.body ||\n\t\telement === root_target ||\n\t\telement instanceof MediaQueryList ||\n\t\t/** @type {Element} */ (element).contains(root_target)\n\t) {\n\t\topts.delegated = false;\n\t}\n\n\tvar remove_listener = create_event(type, element, handler, opts);\n\n\treturn () => {\n\t\tremove_listener();\n\t};\n}\n\nvar last_propagated_event = null;\n\n/**\n * @this {EventTarget}\n * @param {Event} event\n * @returns {void}\n */\nexport function handle_event_propagation(event) {\n\tvar handler_element = this;\n\tvar owner_document = /** @type {Node} */ (handler_element).ownerDocument;\n\tvar event_name = event.type;\n\tvar path = event.composedPath?.() || [];\n\tvar current_target = /** @type {null | Element} */ (path[0] || event.target);\n\n\tlast_propagated_event = event;\n\n\t// composedPath contains list of nodes the event has propagated through.\n\t// We check __root to skip all nodes below it in case this is a\n\t// parent of the __root node, which indicates that there's nested\n\t// mounted apps. In this case we don't want to trigger events multiple times.\n\tvar path_idx = 0;\n\n\t// @ts-expect-error is added below\n\tvar handled_at = last_propagated_event === event && event.__root;\n\n\tif (handled_at) {\n\t\tvar at_idx = path.indexOf(handled_at);\n\t\tif (\n\t\t\tat_idx !== -1 &&\n\t\t\t(handler_element === document || handler_element === /** @type {any} */ (window))\n\t\t) {\n\t\t\t// This is the fallback document listener or a window listener, but the event was already handled\n\t\t\t// -> ignore, but set handle_at to document/window so that we're resetting the event\n\t\t\t// chain in case someone manually dispatches the same event object again.\n\t\t\t// @ts-expect-error\n\t\t\tevent.__root = handler_element;\n\t\t\treturn;\n\t\t}\n\n\t\t// We're deliberately not skipping if the index is higher, because\n\t\t// someone could create an event programmatically and emit it multiple times,\n\t\t// in which case we want to handle the whole propagation chain properly each time.\n\t\t// (this will only be a false negative if the event is dispatched multiple times and\n\t\t// the fallback document listener isn't reached in between, but that's super rare)\n\t\tvar handler_idx = path.indexOf(handler_element);\n\t\tif (handler_idx === -1) {\n\t\t\t// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)\n\t\t\t// so guard against that, too, and assume that everything was handled at this point.\n\t\t\treturn;\n\t\t}\n\n\t\tif (at_idx <= handler_idx) {\n\t\t\tpath_idx = at_idx;\n\t\t}\n\t}\n\n\tcurrent_target = /** @type {Element} */ (path[path_idx] || event.target);\n\t// there can only be one delegated event per element, and we either already handled the current target,\n\t// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe\n\t// to handle a possible delegated event on it later (through the root delegation listener for example).\n\tif (current_target === handler_element) return;\n\n\t// Proxy currentTarget to correct target\n\tdefine_property(event, 'currentTarget', {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn current_target || owner_document;\n\t\t},\n\t});\n\n\tvar previous_block = active_block;\n\tvar previous_reaction = active_reaction;\n\tvar previous_tracking = tracking;\n\n\tset_active_block(null);\n\tset_active_reaction(null);\n\tset_tracking(false);\n\n\ttry {\n\t\t/**\n\t\t * @type {unknown}\n\t\t */\n\t\tvar throw_error;\n\t\t/**\n\t\t * @type {unknown[]}\n\t\t */\n\t\tvar other_errors = [];\n\n\t\twhile (current_target !== null) {\n\t\t\t/** @type {null | Element} */\n\t\t\tvar parent_element =\n\t\t\t\tcurrent_target.assignedSlot ||\n\t\t\t\tcurrent_target.parentNode ||\n\t\t\t\t/** @type {any} */ (current_target).host ||\n\t\t\t\tnull;\n\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvar delegated = current_target['__' + event_name];\n\n\t\t\t\tif (delegated !== undefined && !(/** @type {any} */ (current_target).disabled)) {\n\t\t\t\t\tif (is_array(delegated)) {\n\t\t\t\t\t\tfor (var i = 0; i < delegated.length; i++) {\n\t\t\t\t\t\t\tdelegated[i].call(current_target, event);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelegated.call(current_target, event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (throw_error) {\n\t\t\t\t\tother_errors.push(error);\n\t\t\t\t} else {\n\t\t\t\t\tthrow_error = error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (event.cancelBubble || parent_element === handler_element || parent_element === null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_target = parent_element;\n\t\t}\n\n\t\tif (throw_error) {\n\t\t\tfor (let error of other_errors) {\n\t\t\t\t// Throw the rest of the errors, one-by-one on a microtask\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t}\n\t\t\tthrow throw_error;\n\t\t}\n\t} finally {\n\t\tset_active_block(previous_block);\n\t\t// @ts-expect-error is used above\n\t\tevent.__root = handler_element;\n\t\t// @ts-ignore remove proxy on currentTarget\n\t\tdelete event.currentTarget;\n\t\tset_active_block(previous_block);\n\t\tset_active_reaction(previous_reaction);\n\t\tset_tracking(previous_tracking);\n\t}\n}\n\n/**\n * @param {string} event_name\n * @param {EventTarget} dom\n * @param {EventListener} handler\n * @param {AddEventOptions} options\n * @returns {() => void}\n */\nfunction create_event(event_name, dom, handler, options) {\n\tvar is_delegated = true;\n\n\tif (is_capture_event(event_name)) {\n\t\tevent_name = event_name_from_capture(event_name);\n\n\t\tif (!('capture' in options) || options.capture !== false) {\n\t\t\toptions.capture = true;\n\t\t}\n\t}\n\n\tevent_name =\n\t\toptions.customName && options.customName?.length\n\t\t\t? options.customName\n\t\t\t: event_name.toLowerCase();\n\n\tif (\n\t\toptions.delegated === false ||\n\t\toptions.capture ||\n\t\toptions.passive ||\n\t\toptions.once ||\n\t\toptions.signal ||\n\t\tis_non_delegated(event_name)\n\t) {\n\t\tis_delegated = false;\n\t}\n\n\tif (is_delegated) {\n\t\tvar prop = '__' + event_name;\n\t\tvar target = /** @type {DelegatedEventTarget} */ (dom);\n\t\tvar current = target[prop];\n\n\t\tif (current === undefined) {\n\t\t\ttarget[prop] = handler;\n\t\t} else if (is_array(current)) {\n\t\t\tif (!current.includes(handler)) {\n\t\t\t\tcurrent.push(handler);\n\t\t\t}\n\t\t} else {\n\t\t\tif (current !== handler) {\n\t\t\t\ttarget[prop] = [current, handler];\n\t\t\t}\n\t\t}\n\n\t\tdelegate([event_name]);\n\t\treturn () => {\n\t\t\tvar handlers = target[prop];\n\t\t\tif (is_array(handlers)) {\n\t\t\t\tvar filtered = handlers.filter((h) => h !== handler);\n\t\t\t\ttarget[prop] =\n\t\t\t\t\tfiltered.length === 0 ? undefined : filtered.length === 1 ? filtered[0] : filtered;\n\t\t\t} else {\n\t\t\t\ttarget[prop] = undefined;\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * @type {EventListener}\n\t * @this {Element}\n\t */\n\tfunction target_handler(event) {\n\t\tvar previous_block = active_block;\n\t\tvar previous_reaction = active_reaction;\n\t\tvar previous_tracking = tracking;\n\n\t\ttry {\n\t\t\tset_active_block(null);\n\t\t\tset_active_reaction(null);\n\t\t\tset_tracking(false);\n\n\t\t\tif (!options.capture) {\n\t\t\t\t// Only call in the bubble phase, else delegated events would be called before the capturing events\n\t\t\t\thandle_event_propagation.call(dom, event);\n\t\t\t}\n\t\t\tif (!event.cancelBubble) {\n\t\t\t\treturn handler?.call(this, event);\n\t\t\t}\n\t\t} finally {\n\t\t\tset_active_block(previous_block);\n\t\t\tset_active_reaction(previous_reaction);\n\t\t\tset_tracking(previous_tracking);\n\t\t}\n\t}\n\n\tvar event_options = get_event_options(options);\n\n\tdom.addEventListener(event_name, target_handler, event_options);\n\treturn () => {\n\t\tdom.removeEventListener(event_name, target_handler, event_options);\n\t};\n}\n\n/**\n * @param {string} event_name\n * @param {Element} dom\n * @param {EventListener | AddEventObject} handler\n * @returns {() => void}\n */\nexport function event(event_name, dom, handler) {\n\t/** @type AddEventOptions */\n\tvar options = {};\n\t/** @type {EventListener} */\n\tvar event_handler;\n\n\tif (typeof handler === 'object' && 'handleEvent' in handler) {\n\t\t({ handleEvent: event_handler, ...options } = handler);\n\t} else {\n\t\tevent_handler = handler;\n\t}\n\n\treturn create_event(event_name, dom, event_handler, options);\n}\n\n/**\n * Reactive version of event that automatically cleans up and re-attaches\n * when the handler changes\n * @param {string} event_name\n * @param {Element} dom\n * @param {() => EventListener | AddEventObject} get_handler\n */\nexport function render_event(event_name, dom, get_handler) {\n\t/** @type {EventListener | AddEventObject | undefined} */\n\tvar prev;\n\t/** @type {(() => void) | undefined} */\n\tvar remove_listener;\n\n\trender(() => {\n\t\tvar handler = get_handler();\n\n\t\tif (handler !== prev) {\n\t\t\tif (remove_listener) {\n\t\t\t\tremove_listener();\n\t\t\t\tremove_listener = undefined;\n\t\t\t}\n\n\t\t\tprev = handler;\n\n\t\t\tif (handler) {\n\t\t\t\tremove_listener = event(event_name, dom, handler);\n\t\t\t}\n\t\t}\n\t});\n}\n\n/**\n * @param {Array<string>} events\n * @returns {void}\n */\nexport function delegate(events) {\n\tfor (var i = 0; i < events.length; i++) {\n\t\tall_registered_events.add(events[i]);\n\t}\n\n\tfor (var fn of root_event_handles) {\n\t\tfn(events);\n\t}\n}\n\n/** @param {Element} target */\nexport function handle_root_events(target) {\n\tvar registered_events = new Set();\n\troot_target = target;\n\n\t/**\n\t * @typedef {Object} EventHandleOptions\n\t * @property {boolean} [passive]\n\t */\n\n\t/**\n\t * @typedef {(\n\t *   events: Array<string>\n\t * ) => void} EventHandle\n\t */\n\n\t/** @type {EventHandle} */\n\tvar event_handle = (/** @type {Array<string>} */ events) => {\n\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\tvar event_name = events[i];\n\n\t\t\tif (registered_events.has(event_name)) continue;\n\t\t\tregistered_events.add(event_name);\n\n\t\t\t/** @type {boolean} */\n\t\t\tvar passive = is_passive_event(event_name);\n\n\t\t\t/** @type {EventHandleOptions} */\n\t\t\tvar options = { passive };\n\n\t\t\ttarget.addEventListener(event_name, handle_event_propagation, options);\n\t\t}\n\t};\n\n\tevent_handle(array_from(all_registered_events));\n\troot_event_handles.add(event_handle);\n\n\treturn () => {\n\t\tfor (var event_name of registered_events) {\n\t\t\ttarget.removeEventListener(event_name, handle_event_propagation);\n\t\t}\n\t\troot_event_handles.delete(event_handle);\n\t\troot_target = null;\n\t};\n}\n",
    "function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;",
    "/** @type {Map<string, string>} */\nconst normalized_properties_cache = new Map();\n\n/**\n * Takes a camelCased string and returns a hyphenated string\n * @param {string} str\n * @returns {string}\n * @example\n * normalize_css_property_name('backgroundColor') // 'background-color'\n */\nexport function normalize_css_property_name(str) {\n\tif (str.startsWith('--')) return str;\n\n\tlet normalized_result = normalized_properties_cache.get(str);\n\tif (normalized_result != null) {\n\t\treturn normalized_result;\n\t}\n\n\tnormalized_result = str.replace(/[A-Z]/g, m => '-' + m.toLowerCase());\n\tnormalized_properties_cache.set(str, normalized_result);\n\n\treturn normalized_result;\n}\n",
    "/** @import { Block } from '#client' */\n\nimport { destroy_block, ref } from './blocks.js';\nimport { REF_PROP } from './constants.js';\nimport {\n\tget_descriptors,\n\tget_own_property_symbols,\n\tget_prototype_of,\n\tis_tracked_object,\n} from './utils.js';\nimport { event } from './events.js';\nimport { get_attribute_event_name, is_event_attribute } from '../../../utils/events.js';\nimport { get } from './runtime.js';\nimport { clsx } from 'clsx';\nimport { normalize_css_property_name } from '../../../utils/normalize_css_property_name.js';\n\n/**\n * @param {Text} text\n * @param {any} value\n * @returns {void}\n */\nexport function set_text(text, value) {\n\t// For objects, we apply string coercion\n\tvar str = value == null ? '' : typeof value === 'object' ? value + '' : value;\n\t// @ts-expect-error\n\tif (str !== (text.__t ??= text.nodeValue)) {\n\t\t// @ts-expect-error\n\t\ttext.__t = str;\n\t\ttext.nodeValue = str + '';\n\t}\n}\n\n/** @type {Map<string, string[]>} */\nvar setters_cache = new Map();\n\n/**\n * @param {Element} element\n * @returns {string[]}\n */\nfunction get_setters(element) {\n\tvar setters = setters_cache.get(element.nodeName);\n\tif (setters) return setters;\n\tsetters_cache.set(element.nodeName, (setters = []));\n\n\tvar descriptors;\n\tvar proto = element; // In the case of custom elements there might be setters on the instance\n\tvar element_proto = Element.prototype;\n\n\t// Stop at Element, from there on there's only unnecessary setters we're not interested in\n\t// Do not use constructor.name here as that's unreliable in some browser environments\n\twhile (element_proto !== proto) {\n\t\tdescriptors = get_descriptors(proto);\n\n\t\tfor (var key in descriptors) {\n\t\t\tif (descriptors[key].set) {\n\t\t\t\tsetters.push(key);\n\t\t\t}\n\t\t}\n\n\t\tproto = get_prototype_of(proto);\n\t}\n\n\treturn setters;\n}\n\n/**\n * @param {Element} element\n * @param {any} value\n * @param {Record<string, string> | undefined} prev\n * @returns {void}\n */\nexport function set_style(element, value, prev = {}) {\n\tif (value == null) {\n\t\telement.removeAttribute('style');\n\t} else if (typeof value !== 'string') {\n\t\tapply_styles(/** @type {HTMLElement} */ (element), value, prev);\n\t} else {\n\t\t// @ts-ignore\n\t\telement.style.cssText = value;\n\t}\n}\n\n/**\n * @param {Element} element\n * @param {string} attribute\n * @param {any} value\n * @returns {void}\n */\nexport function set_attribute(element, attribute, value) {\n\tif (value == null) {\n\t\telement.removeAttribute(attribute);\n\t} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {\n\t\t/** @type {any} */ (element)[attribute] = value;\n\t} else {\n\t\telement.setAttribute(attribute, value);\n\t}\n}\n\n/**\n * @param {HTMLElement} element\n * @param {Record<string, string | number>} new_styles\n * @param {Record<string, string>} prev\n */\nfunction apply_styles(element, new_styles, prev) {\n\tconst style = element.style;\n\n\t// Apply new styles\n\tfor (const key in new_styles) {\n\t\tconst css_prop = normalize_css_property_name(key);\n\t\tconst value = String(new_styles[key]);\n\n\t\tif (!(key in prev) || prev[key] !== value) {\n\t\t\tstyle.setProperty(css_prop, value);\n\t\t}\n\t}\n\n\t// Remove properties that were in prev but not in new_styles\n\tfor (const key in prev) {\n\t\tif (!(key in new_styles)) {\n\t\t\tconst css_prop = normalize_css_property_name(key);\n\t\t\tstyle.removeProperty(css_prop);\n\t\t}\n\t}\n}\n\n/**\n * Helper function to set a single attribute\n * @param {Element} element\n * @param {string} key\n * @param {any} value\n * @param {Record<string, (() => void) | undefined>} remove_listeners\n * @param {Record<string | symbol, any>} prev\n */\nfunction set_attribute_helper(element, key, value, remove_listeners, prev) {\n\tif (key === 'class') {\n\t\tconst is_html = element.namespaceURI === 'http://www.w3.org/1999/xhtml';\n\t\tset_class(/** @type {HTMLElement} */ (element), value, undefined, is_html);\n\t} else if (key === 'style') {\n\t\tset_style(element, value, prev.style);\n\t} else if (key === '#class') {\n\t\t// Special case for static class when spreading props\n\t\telement.classList.add(value);\n\t} else if (typeof key === 'string' && is_event_attribute(key)) {\n\t\t// Handle event handlers in spread props\n\t\tconst event_name = get_attribute_event_name(key, value);\n\t\tif (remove_listeners[key]) {\n\t\t\tremove_listeners[key]();\n\t\t}\n\t\tremove_listeners[key] = event(event_name, element, value);\n\t} else {\n\t\tset_attribute(element, key, value);\n\t}\n}\n\n/**\n * @param {HTMLElement} dom\n * @param {string} value\n * @param {string} [hash]\n * @param {boolean} [is_html]\n * @returns {void}\n */\nexport function set_class(dom, value, hash, is_html = true) {\n\tvar class_value =\n\t\tvalue == null\n\t\t\t? (hash ?? '')\n\t\t\t: // Fast-path for string values\n\t\t\t\ttypeof value === 'string'\n\t\t\t\t? value + (hash ? ' ' + hash : '')\n\t\t\t\t: clsx([value, hash]);\n\n\t// Removing the attribute when the value is only an empty string causes\n\t// performance issues vs simply making the className an empty string. So\n\t// we should only remove the class if the the value is nullish.\n\tif (value == null && hash === undefined) {\n\t\tdom.removeAttribute('class');\n\t} else {\n\t\tif (is_html) {\n\t\t\tdom.className = class_value;\n\t\t} else {\n\t\t\tdom.setAttribute('class', class_value);\n\t\t}\n\t}\n}\n\n/**\n * @param {HTMLInputElement | HTMLProgressElement} element\n * @param {any} value\n * @returns {void}\n */\nexport function set_value(element, value) {\n\t// @ts-expect-error\n\tvar attributes = (element.__attributes ??= {});\n\n\tif (\n\t\tattributes.value ===\n\t\t\t(attributes.value =\n\t\t\t\t// treat null and undefined the same for the initial value\n\t\t\t\tvalue ?? undefined) ||\n\t\t// `progress` elements always need their value set when it's `0`\n\t\t(element.value === value && (value !== 0 || element.nodeName !== 'PROGRESS'))\n\t) {\n\t\treturn;\n\t}\n\n\telement.value = value ?? '';\n}\n\n/**\n * @param {HTMLInputElement} element\n * @param {boolean} checked\n * @returns {void}\n */\nexport function set_checked(element, checked) {\n\t// @ts-expect-error\n\tvar attributes = (element.__attributes ??= {});\n\n\tif (\n\t\tattributes.checked ===\n\t\t(attributes.checked =\n\t\t\t// treat null and undefined the same for the initial value\n\t\t\tchecked ?? undefined)\n\t) {\n\t\treturn;\n\t}\n\n\telement.checked = checked;\n}\n\n/**\n * @param {HTMLOptionElement} element\n * @param {boolean} selected\n * @returns {void}\n */\nexport function set_selected(element, selected) {\n\tif (selected) {\n\t\t// The selected option could've changed via user selection, and\n\t\t// setting the value without this check would set it back.\n\t\tif (!element.hasAttribute('selected')) {\n\t\t\telement.setAttribute('selected', '');\n\t\t}\n\t} else {\n\t\telement.removeAttribute('selected');\n\t}\n}\n\n/**\n * @param {Element} element\n * @param {() => Record<string | symbol, any>} fn\n * @returns {() => void}\n */\nexport function apply_element_spread(element, fn) {\n\t/** @type {Record<string | symbol, any>} */\n\tvar prev = {};\n\t/** @type {Record<symbol, Block | undefined>} */\n\tvar effects = {};\n\t/** @type {Record<string | symbol, (() => void) | undefined>} */\n\tvar remove_listeners = {};\n\n\treturn () => {\n\t\tvar next = fn();\n\n\t\tfor (const symbol of get_own_property_symbols(effects)) {\n\t\t\tif (!next[symbol] && effects[symbol]) {\n\t\t\t\tdestroy_block(effects[symbol]);\n\t\t\t\teffects[symbol] = undefined;\n\t\t\t}\n\t\t}\n\n\t\tfor (const symbol of get_own_property_symbols(next)) {\n\t\t\tvar ref_fn = next[symbol];\n\n\t\t\tif (symbol.description === REF_PROP && (!(symbol in prev) || ref_fn !== prev[symbol])) {\n\t\t\t\tif (effects[symbol]) {\n\t\t\t\t\tdestroy_block(effects[symbol]);\n\t\t\t\t}\n\t\t\t\teffects[symbol] = ref(element, () => ref_fn);\n\t\t\t}\n\n\t\t\tnext[symbol] = ref_fn;\n\t\t}\n\n\t\tfor (let key in remove_listeners) {\n\t\t\t// Remove event listeners that are no longer present\n\t\t\tif (!(key in next) && remove_listeners[key]) {\n\t\t\t\tremove_listeners[key]();\n\t\t\t\tremove_listeners[key] = undefined;\n\t\t\t}\n\t\t}\n\n\t\tfor (const key in prev) {\n\t\t\tif (!(key in next)) {\n\t\t\t\tif (key === '#class') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tset_attribute_helper(element, key, null, remove_listeners, prev);\n\t\t\t}\n\t\t}\n\n\t\t/** @type {typeof prev} */\n\t\tconst current = {};\n\t\tfor (const key in next) {\n\t\t\tif (key === 'children') continue;\n\n\t\t\tlet value = next[key];\n\t\t\tif (is_tracked_object(value)) {\n\t\t\t\tvalue = get(value);\n\t\t\t}\n\t\t\tcurrent[key] = value;\n\n\t\t\tif (key in prev && prev[key] === value && key !== '#class') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tset_attribute_helper(element, key, value, remove_listeners, prev);\n\t\t}\n\t\tprev = current;\n\t};\n}\n",
    "/** @import { Block, Derived, CompatOptions, Component } from '#client' */\n\nimport {\n\tBLOCK_HAS_RUN,\n\tBRANCH_BLOCK,\n\tDERIVED,\n\tCONTAINS_TEARDOWN,\n\tDESTROYED,\n\tEFFECT_BLOCK,\n\tPAUSED,\n\tRENDER_BLOCK,\n\tROOT_BLOCK,\n\tTRY_BLOCK,\n\tHEAD_BLOCK,\n} from './constants.js';\nimport { next_sibling } from './operations.js';\nimport { apply_element_spread } from './render.js';\nimport {\n\tactive_block,\n\tactive_component,\n\tactive_reaction,\n\tcreate_component_ctx,\n\tis_block_dirty,\n\trun_block,\n\trun_teardown,\n\tschedule_update,\n} from './runtime.js';\nimport { suspend } from './try.js';\n\n/**\n * @param {Function} fn\n */\nexport function user_effect(fn) {\n\tif (active_block === null) {\n\t\tthrow new Error(\n\t\t\t'effect() must be called within an active context, such as a component or effect',\n\t\t);\n\t}\n\n\tvar component = active_component;\n\tif (component !== null && !component.m) {\n\t\tvar e = (component.e ??= []);\n\t\te.push({\n\t\t\tb: active_block,\n\t\t\tfn,\n\t\t\tr: active_reaction,\n\t\t});\n\n\t\treturn;\n\t}\n\n\treturn block(EFFECT_BLOCK, fn);\n}\n\n/**\n * @param {Function} fn\n */\nexport function effect(fn) {\n\treturn block(EFFECT_BLOCK, fn);\n}\n\n/**\n * @param {Function} fn\n * @param {any} [state]\n * @param {number} [flags]\n */\nexport function render(fn, state, flags = 0) {\n\treturn block(RENDER_BLOCK | flags, fn, state);\n}\n\n/**\n * @param {any} element\n * @param {any} fn\n * @param {number} [flags]\n */\nexport function render_spread(element, fn, flags = 0) {\n\treturn block(RENDER_BLOCK | flags, apply_element_spread(element, fn));\n}\n\n/**\n * @param {Function} fn\n * @param {number} [flags]\n * @param {any} [state]\n */\nexport function branch(fn, flags = 0, state = null) {\n\treturn block(BRANCH_BLOCK | flags, fn, state);\n}\n\n/**\n * @param {() => any} fn\n */\nexport function async(fn) {\n\treturn block(BRANCH_BLOCK, async () => {\n\t\tconst unsuspend = suspend();\n\t\tawait fn();\n\t\tunsuspend();\n\t});\n}\n\n/**\n * @param {Element} element\n * @param {() => (element: Element) => (void | (() => void))} get_fn\n * @returns {Block}\n */\nexport function ref(element, get_fn) {\n\t/** @type {(element: Element) => (void | (() => void) | undefined)} */\n\tvar ref_fn;\n\t/** @type {Block | null} */\n\tvar e;\n\n\treturn block(RENDER_BLOCK, () => {\n\t\tif (ref_fn !== (ref_fn = get_fn())) {\n\t\t\tif (e) {\n\t\t\t\tdestroy_block(e);\n\t\t\t\te = null;\n\t\t\t}\n\n\t\t\tif (ref_fn) {\n\t\t\t\te = branch(() => {\n\t\t\t\t\teffect(() => {\n\t\t\t\t\t\treturn ref_fn(element);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n}\n\n/**\n * @param {() => (void | (() => void))} fn\n * @param {CompatOptions} [compat]\n * @returns {Block}\n */\nexport function root(fn, compat) {\n\tvar target_fn = fn;\n\n\tif (compat != null) {\n\t\t/** @type {Array<void | (() => void)>} */\n\t\tvar unmounts = [];\n\t\tfor (var key in compat) {\n\t\t\tvar api = compat[key];\n\t\t\tunmounts.push(api.createRoot());\n\t\t}\n\t\ttarget_fn = () => {\n\t\t\tvar component_unmount = fn();\n\n\t\t\treturn () => {\n\t\t\t\tcomponent_unmount?.();\n\t\t\t\tfor (var unmount of unmounts) {\n\t\t\t\t\tunmount?.();\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\n\treturn block(ROOT_BLOCK, target_fn, { compat }, create_component_ctx());\n}\n\n/**\n * @param {() => void} fn\n * @param {any} state\n * @returns {Block}\n */\nexport function create_try_block(fn, state) {\n\treturn block(TRY_BLOCK, fn, state);\n}\n\n/**\n * @param {Block} block\n * @param {Block} parent_block\n */\nfunction push_block(block, parent_block) {\n\tvar parent_last = parent_block.last;\n\tif (parent_last === null) {\n\t\tparent_block.last = parent_block.first = block;\n\t} else {\n\t\tparent_last.next = block;\n\t\tblock.prev = parent_last;\n\t\tparent_block.last = block;\n\t}\n}\n\n/**\n * @param {number} flags\n * @param {Function} fn\n * @param {any} [state]\n * @param {Component} [co]\n * @returns {Block}\n */\nexport function block(flags, fn, state = null, co) {\n\t/** @type {Block} */\n\tvar block = {\n\t\tco: co || active_component,\n\t\td: null,\n\t\tfirst: null,\n\t\tf: flags,\n\t\tfn,\n\t\tlast: null,\n\t\tnext: null,\n\t\tp: active_block,\n\t\tprev: null,\n\t\ts: state,\n\t\tt: null,\n\t};\n\n\tif (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {\n\t\t/* prettier-ignore */\n\t\t(/** @type {Derived} */ (active_reaction).blocks ??= []).push(block);\n\t}\n\n\tif (active_block !== null) {\n\t\tpush_block(block, active_block);\n\t}\n\n\tif ((flags & EFFECT_BLOCK) !== 0) {\n\t\tschedule_update(block);\n\t} else {\n\t\trun_block(block);\n\t\tblock.f ^= BLOCK_HAS_RUN;\n\t}\n\n\treturn block;\n}\n\n/**\n * @param {Block} parent\n * @param {boolean} [remove_dom]\n */\nexport function destroy_block_children(parent, remove_dom = false) {\n\tvar block = parent.first;\n\tparent.first = parent.last = null;\n\n\tif ((parent.f & CONTAINS_TEARDOWN) !== 0) {\n\t\twhile (block !== null) {\n\t\t\tvar next = block.next;\n\t\t\tdestroy_block(block, remove_dom);\n\t\t\tblock = next;\n\t\t}\n\t}\n}\n\n/**\n * @param {Block} parent\n * @param {boolean} [remove_dom]\n */\nexport function destroy_non_branch_children(parent, remove_dom = false) {\n\tvar block = parent.first;\n\n\tif (\n\t\t(parent.f & CONTAINS_TEARDOWN) === 0 &&\n\t\tparent.first !== null &&\n\t\t(parent.first.f & BRANCH_BLOCK) === 0\n\t) {\n\t\tparent.first = parent.last = null;\n\t} else {\n\t\twhile (block !== null) {\n\t\t\tvar next = block.next;\n\t\t\tif ((block.f & BRANCH_BLOCK) === 0) {\n\t\t\t\tdestroy_block(block, remove_dom);\n\t\t\t}\n\t\t\tblock = next;\n\t\t}\n\t}\n}\n\n/**\n * @param {Block} block\n */\nexport function unlink_block(block) {\n\tvar parent = block.p;\n\tvar prev = block.prev;\n\tvar next = block.next;\n\n\tif (prev !== null) prev.next = next;\n\tif (next !== null) next.prev = prev;\n\n\tif (parent !== null) {\n\t\tif (parent.first === block) parent.first = next;\n\t\tif (parent.last === block) parent.last = prev;\n\t}\n}\n\n/**\n * @param {Block} block\n */\nexport function pause_block(block) {\n\tif ((block.f & PAUSED) !== 0) {\n\t\treturn;\n\t}\n\tblock.f ^= PAUSED;\n\n\tvar child = block.first;\n\n\twhile (child !== null) {\n\t\tvar next = child.next;\n\t\tpause_block(child);\n\t\tchild = next;\n\t}\n\n\trun_teardown(block);\n}\n\n/**\n * @param {Block} block\n */\nexport function resume_block(block) {\n\tif ((block.f & PAUSED) === 0) {\n\t\treturn;\n\t}\n\tblock.f ^= PAUSED;\n\n\tif (is_block_dirty(block)) {\n\t\tschedule_update(block);\n\t}\n\n\tvar child = block.first;\n\n\twhile (child !== null) {\n\t\tvar next = child.next;\n\t\tresume_block(child);\n\t\tchild = next;\n\t}\n}\n\n/**\n * @param {Block} target_block\n * @returns {boolean}\n */\nexport function is_destroyed(target_block) {\n\t/** @type {Block | null} */\n\tvar block = target_block;\n\n\twhile (block !== null) {\n\t\tvar flags = block.f;\n\n\t\tif ((flags & DESTROYED) !== 0) {\n\t\t\treturn true;\n\t\t}\n\t\tif ((flags & ROOT_BLOCK) !== 0) {\n\t\t\treturn false;\n\t\t}\n\t\tblock = block.p;\n\t}\n\treturn true;\n}\n\n/**\n * @param {Node | null} node\n * @param {Node} end\n */\nexport function remove_block_dom(node, end) {\n\twhile (node !== null) {\n\t\t/** @type {Node | null} */\n\t\tvar next = node === end ? null : next_sibling(node);\n\n\t\t/** @type {Element | Text | Comment} */ (node).remove();\n\t\tnode = next;\n\t}\n}\n\n/**\n * @param {Block} block\n * @param {boolean} [remove_dom]\n */\nexport function destroy_block(block, remove_dom = true) {\n\tblock.f ^= DESTROYED;\n\n\tvar removed = false;\n\tvar f = block.f;\n\n\tif (\n\t\t(remove_dom && (f & (BRANCH_BLOCK | ROOT_BLOCK)) !== 0 && (f & TRY_BLOCK) === 0) ||\n\t\t(f & HEAD_BLOCK) !== 0\n\t) {\n\t\tvar s = block.s;\n\t\tif (s !== null) {\n\t\t\tremove_block_dom(s.start, s.end);\n\t\t\tremoved = true;\n\t\t}\n\t}\n\n\tdestroy_block_children(block, remove_dom && !removed);\n\n\trun_teardown(block);\n\n\tvar parent = block.p;\n\n\t// If the parent doesn't have any children, then skip this work altogether\n\tif (parent !== null && parent.first !== null) {\n\t\tunlink_block(block);\n\t}\n\n\tblock.fn = block.s = block.d = block.p = block.d = block.co = block.t = null;\n}\n",
    "import { DEV } from 'esm-env';\n\nexport function remove_ssr_css() {\n\tif (!document || typeof requestAnimationFrame !== 'function') {\n\t\treturn;\n\t}\n\n\tremove_styles();\n}\n\nfunction remove_styles() {\n\tif (DEV) {\n\t\tconst styles = document.querySelector('style[data-vite-dev-id]');\n\t\tif (styles) {\n\t\t\tremove();\n\t\t} else {\n\t\t\trequestAnimationFrame(remove_styles);\n\t\t}\n\t} else {\n\t\tremove_when_css_loaded(() => requestAnimationFrame(remove));\n\t}\n}\n\nfunction remove() {\n\tdocument.querySelectorAll('style[data-ripple-ssr]').forEach((el) => el.remove());\n}\n\n/**\n * @param {function} callback\n * @returns {void}\n */\nfunction remove_when_css_loaded(callback) {\n\t/** @type {HTMLLinkElement[]} */\n\tconst links = Array.from(document.querySelectorAll('link[rel=\"stylesheet\"]'));\n\tlet remaining = links.length;\n\n\tif (remaining === 0) {\n\t\tcallback();\n\t\treturn;\n\t}\n\n\tconst done = () => {\n\t\tremaining--;\n\t\tif (remaining === 0) {\n\t\t\t// clean up all listeners\n\t\t\tlinks.forEach((link) => {\n\t\t\t\tlink.removeEventListener('load', onLoad);\n\t\t\t\tlink.removeEventListener('error', onError);\n\t\t\t});\n\t\t\tcallback();\n\t\t}\n\t};\n\n\tfunction onLoad() {\n\t\tdone();\n\t}\n\tfunction onError() {\n\t\tdone();\n\t}\n\n\tlinks.forEach((link) => {\n\t\tif (link.sheet) {\n\t\t\t// already loaded (possibly cached)\n\t\t\tdone();\n\t\t} else {\n\t\t\tlink.addEventListener('load', onLoad);\n\t\t\tlink.addEventListener('error', onError);\n\t\t}\n\t});\n}\n",
    "/** @import { Block, Tracked } from '#client' */\n/** @import { TrackedArray } from './array.js' */\n/** @import { TrackedObject } from './object.js' */\n\nimport { get, set, tracked } from './internal/client/runtime.js';\nimport {\n\tarray_prototype,\n\tget_descriptor,\n\tget_prototype_of,\n\tis_array,\n\tobject_prototype,\n} from './internal/client/utils.js';\nimport {\n\tMAX_ARRAY_LENGTH,\n\tTRACKED_ARRAY,\n\tTRACKED_OBJECT,\n\tUNINITIALIZED,\n} from './internal/client/constants.js';\n\n/**\n * @template T\n * @param {T[] | Record<PropertyKey, any>} value\n * @param {Block} block\n * @returns {TrackedArray<T> | TrackedObject<T>}\n */\nexport function proxy(value, block) {\n\t// if non-proxyable, or is already a proxy, return `value`\n\tif (\n\t\ttypeof value !== 'object'\n\t\t|| value === null\n\t\t|| TRACKED_ARRAY in value\n\t\t|| TRACKED_OBJECT in value\n\t) {\n\t\treturn value;\n\t}\n\n\tconst prototype = get_prototype_of(value);\n\n\tif (prototype !== object_prototype && prototype !== array_prototype) {\n\t\treturn value;\n\t}\n\n\t/** @type {Map<any,Tracked>} */\n\tvar tracked_elements = new Map();\n\tvar is_proxied_array = is_array(value);\n\t/** @type {Tracked} */\n\tvar tracked_len;\n\n\tif (is_proxied_array) {\n\t\ttracked_len = tracked(value.length, block);\n\t\ttracked_elements.set('length', tracked_len);\n\t}\n\n\treturn new Proxy(value, {\n\t\t/**\n\t\t * @param {PropertyKey} prop\n\t\t */\n\t\tget(target, prop, receiver) {\n\t\t\tvar t = tracked_elements.get(prop);\n\t\t\tvar exists = prop in target;\n\n\t\t\tif (t === undefined && (!exists || get_descriptor(target, prop)?.writable)) {\n\t\t\t\tt = tracked(exists ? /** @type {any} */ (target)[prop] : UNINITIALIZED, block);\n\t\t\t\ttracked_elements.set(prop, t);\n\t\t\t}\n\n\t\t\tif (t !== undefined) {\n\t\t\t\tvar v = get(t);\n\t\t\t\treturn v === UNINITIALIZED ? undefined : v;\n\t\t\t}\n\n\t\t\tvar result = Reflect.get(target, prop, receiver);\n\n\t\t\tif (typeof result === 'function') {\n\t\t\t\tif (methods_returning_arrays.has(prop)) {\n\t\t\t\t\t/** @type {(this: any, ...args: any[]) => any} */\n\t\t\t\t\treturn function (...args) {\n\t\t\t\t\t\tvar output = Reflect.apply(result, receiver, args);\n\n\t\t\t\t\t\tif (Array.isArray(output) && output !== target) {\n\t\t\t\t\t\t\treturn array_proxy({ elements: output, block, use_array: true });\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn output;\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// When generating an iterator, we need to ensure that length is tracked\n\t\t\t\tif (is_proxied_array && (prop === 'entries' || prop === 'values' || prop === 'keys')) {\n\t\t\t\t\treceiver.length;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\n\t\tset(target, prop, value, receiver) {\n\t\t\tvar t = tracked_elements.get(prop);\n\t\t\tvar exists = prop in target;\n\n\t\t\tif (is_proxied_array && prop === 'length' && t !== undefined) {\n\t\t\t\tfor (var i = value; i < t.__v; i += 1) {\n\t\t\t\t\tvar other_t = tracked_elements.get(i + '');\n\t\t\t\t\tif (other_t !== undefined) {\n\t\t\t\t\t\tset(other_t, UNINITIALIZED);\n\t\t\t\t\t} else if (i in target) {\n\t\t\t\t\t\t// If the item exists in the original, we need to create a uninitialized tracked,\n\t\t\t\t\t\t// else a later read of the property would result in a tracked being created with\n\t\t\t\t\t\t// the value of the original item at that index.\n\t\t\t\t\t\tother_t = tracked(UNINITIALIZED, block);\n\t\t\t\t\t\ttracked_elements.set(i + '', other_t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we haven't yet created a tracked for this property, we need to ensure\n\t\t\t// we do so otherwise if we read it later, then the write won't be tracked and\n\t\t\t// the heuristics of effects will be different vs if we had read the proxied\n\t\t\t// object property before writing to that property.\n\t\t\tif (t === undefined) {\n\t\t\t\tif (!exists || get_descriptor(target, prop)?.writable) {\n\t\t\t\t\tt = tracked(undefined, block);\n\t\t\t\t\tset(t, value);\n\n\t\t\t\t\ttracked_elements.set(prop, t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\texists = t.__v !== UNINITIALIZED;\n\n\t\t\t\tset(t, value);\n\t\t\t}\n\n\t\t\tvar descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\n\t\t\t// Set the new value before updating any tracked's so that any listeners get the new value\n\t\t\tif (descriptor?.set) {\n\t\t\t\tdescriptor.set.call(receiver, value);\n\t\t\t}\n\n\t\t\tif (!exists && is_proxied_array && typeof prop === 'string') {\n\t\t\t\t// If we have mutated an array directly, we might need to\n\t\t\t\t// signal that length has also changed. Do it before updating metadata\n\t\t\t\t// to ensure that iterating over the array as a result of a metadata update\n\t\t\t\t// will not cause the length to be out of sync.\n\t\t\t\tvar n = Number(prop);\n\n\t\t\t\tif (Number.isInteger(n) && n >= tracked_len.__v) {\n\t\t\t\t\tset(tracked_len, n + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\tsetPrototypeOf() {\n\t\t\tthrow new Error(`Cannot set prototype of ${is_proxied_array ? '\\`TrackedArray\\`' : '\\`TrackedObject\\`'}`);\n\t\t},\n\n\t\tdeleteProperty(target, prop) {\n\t\t\tvar t = tracked_elements.get(prop);\n\n\t\t\tif (t === undefined) {\n\t\t\t\tif (prop in target) {\n\t\t\t\t\tconst t = tracked(UNINITIALIZED, block);\n\t\t\t\t\ttracked_elements.set(prop, t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tset(t, UNINITIALIZED);\n\t\t\t}\n\n\t\t\treturn Reflect.deleteProperty(target, prop);\n\t\t},\n\n\t\thas(target, prop) {\n\t\t\tif (is_proxied_array && prop === TRACKED_ARRAY) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (prop === TRACKED_OBJECT) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tvar t = tracked_elements.get(prop);\n\t\t\tvar exists = (t !== undefined && t.__v !== UNINITIALIZED) || Reflect.has(target, prop);\n\n\t\t\tif (t !== undefined || !exists || get_descriptor(target, prop)?.writable) {\n\t\t\t\tif (t === undefined) {\n\t\t\t\t\tt = tracked(exists ?  /** @type {any} */ (target)[prop] : UNINITIALIZED, block);\n\n\t\t\t\t\ttracked_elements.set(prop, t);\n\t\t\t\t}\n\n\t\t\t\tvar value = get(t);\n\t\t\t\tif (value === UNINITIALIZED) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn exists;\n\t\t},\n\n\t\tdefineProperty(_, prop, descriptor) {\n\t\t\tif (\n\t\t\t\t!('value' in descriptor) ||\n\t\t\t\tdescriptor.configurable === false ||\n\t\t\t\tdescriptor.enumerable === false ||\n\t\t\t\tdescriptor.writable === false\n\t\t\t) {\n\t\t\t\t// we disallow non-basic descriptors, because unless they are applied to the\n\t\t\t\t// target object  which we avoid, so that state can be forked  we will run\n\t\t\t\t// afoul of the various invariants\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Only basic property descriptors are supported with value and configurable, enumerable, and writable set to true',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tvar t = tracked_elements.get(prop);\n\n\t\t\tif (t === undefined) {\n\t\t\t\tt = tracked(descriptor.value, block);\n\t\t\t\ttracked_elements.set(prop, t);\n\t\t\t} else {\n\t\t\t\tset(t, descriptor.value);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\townKeys(target) {\n\t\t\tvar own_keys = Reflect.ownKeys(target).filter((key) => {\n\t\t\t\tvar t = tracked_elements.get(key);\n\t\t\t\treturn t === undefined || t.__v !== UNINITIALIZED;\n\t\t\t});\n\n\t\t\tfor (var [key, t] of tracked_elements) {\n\t\t\t\tif (t.__v !== UNINITIALIZED && !(key in target)) {\n\t\t\t\t\town_keys.push(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn own_keys;\n\t\t},\n\n\t\tgetOwnPropertyDescriptor(target, prop) {\n\t\t\tvar descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\n\t\t\tif (descriptor && 'value' in descriptor) {\n\t\t\t\tvar t = tracked_elements.get(prop);\n\t\t\t\tif (t) descriptor.value = get(t);\n\t\t\t} else if (descriptor === undefined) {\n\t\t\t\tvar t = tracked_elements.get(prop);\n\t\t\t\tvar value = t?.__v;\n\n\t\t\t\tif (t !== undefined && value !== UNINITIALIZED) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\twritable: true\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn descriptor;\n\t\t},\n\n\t});\n}\n\n/**\n * @template T\n * @param {{\n *  elements: Iterable<T>,\n *  block: Block,\n *  from_static?: boolean,\n *  use_array?: boolean\n * }} params\n * @returns {TrackedArray<T>}\n */\nexport function array_proxy({ elements, block, from_static = false, use_array = false }) {\n\tvar arr;\n\tvar first;\n\n\tif (\n\t\tfrom_static &&\n\t\t(first = get_first_if_length(/** @type {Array<T>} */(elements))) !== undefined\n\t) {\n\t\tarr = new Array();\n\t\tarr[0] = first;\n\t} else if (use_array) {\n\t\tarr = elements;\n\t} else {\n\t\tarr = new Array(...elements);\n\t}\n\n\treturn proxy(arr, block);\n}\n\n/**\n * @template {object} T\n * @param {T} obj\n * @param {Block} block\n * @returns {TrackedObject<T>}\n */\nexport function object_proxy(obj, block) {\n\treturn proxy(obj, block);\n}\n\n/** @type {Set<PropertyKey>} */\nconst methods_returning_arrays = new Set([\n\t'concat',\n\t'filter',\n\t'flat',\n\t'flatMap',\n\t'map',\n\t'slice',\n\t'splice',\n\t'toReversed',\n\t'toSorted',\n\t'toSpliced',\n\t'with',\n]);\n\n/**\n * @template T\n * @param {Array<T>} array\n * @returns {number | void}\n */\nfunction get_first_if_length(array) {\n\tvar first = array[0];\n\n\tif (\n\t\tarray.length === 1 &&\n\t\t0 in array &&\n\t\tNumber.isInteger(first) &&\n    /** @type {number} */ (first) >= 0 &&\n    /** @type {number} */ (first) <= MAX_ARRAY_LENGTH\n\t) {\n\t\treturn /** @type {number} */ (first);\n\t}\n}\n",
    "/** @import { Block } from '#client' */\nimport { safe_scope } from './internal/client/runtime.js';\nimport { array_proxy } from './proxy.js';\n\n/**\n * @template T\n * @constructor\n * @param {...T} elements\n * @returns {TrackedArray<T>}\n */\nexport function TrackedArray(...elements) {\n  if (!new.target) {\n    throw new Error(\"TrackedArray must be called with 'new'\");\n  }\n\n  var block = safe_scope();\n  return array_proxy({ elements, block });\n}\n\n/**\n * @template T\n * @param {ArrayLike<T> | Iterable<T>} arrayLike\n * @param {(v: T, k: number) => any | undefined} [mapFn]\n * @param {*} [thisArg]\n * @returns {TrackedArray<T>}\n */\nTrackedArray.from = function (arrayLike, mapFn, thisArg) {\n  var block = safe_scope();\n  var elements = mapFn ? Array.from(arrayLike, mapFn, thisArg) : Array.from(arrayLike);\n  return array_proxy({ elements, block, from_static: true });\n};\n\n/**\n * @template T\n * @param {...T} items\n * @returns {TrackedArray<T>}\n */\nTrackedArray.of = function (...items) {\n  var block = safe_scope();\n  var elements = Array.of(...items);\n  return array_proxy({ elements, block, from_static: true });\n};\n\n/**\n * @template T\n * @param {ArrayLike<T> | Iterable<T>} arrayLike\n * @param {(v: T, k: number) => any | undefined} [mapFn]\n * @param {any} [thisArg]\n * @returns {Promise<TrackedArray<T>>}\n */\nTrackedArray.fromAsync = async function (arrayLike, mapFn, thisArg) {\n  var block = safe_scope();\n  var elements = mapFn\n    ? await Array.fromAsync(arrayLike, mapFn, thisArg)\n    : await Array.fromAsync(arrayLike);\n  return array_proxy({ elements, block, from_static: true });\n};\n\n/**\n * @template T\n * @param {Array<T>} elements\n * @param {Block} block\n * @returns {TrackedArray<T>}\n */\nexport function tracked_array(elements, block) {\n  return array_proxy({ elements, block, from_static: true });\n}\n",
    "/** @import { Block, Tracked } from '#client' */\nimport { get, increment, safe_scope, set, tracked, with_scope } from './internal/client/runtime.js';\n\nconst introspect_methods = ['entries', 'forEach', 'keys', 'values', Symbol.iterator];\n\nconst compare_other_methods = ['isDisjointFrom', 'isSubsetOf', 'isSupersetOf'];\n\nconst new_other_methods = ['difference', 'intersection', 'symmetricDifference', 'union'];\n\nlet init = false;\n\n/**\n * @template T\n * @extends {Set<T>}\n * @returns {TrackedSet<T>}\n */\nexport class TrackedSet extends Set {\n\t/** @type {Tracked} */\n\t#tracked_size;\n\t/** @type {Map<T, Tracked>} */\n\t#tracked_items = new Map();\n\t/** @type {Block} */\n\t#block;\n\n\t/**\n\t * @param {Iterable<T>} [iterable]\n\t */\n\tconstructor(iterable) {\n\t\tsuper();\n\n\t\tvar block = this.#block = safe_scope();\n\n\t\tif (iterable) {\n\t\t\tfor (var item of iterable) {\n\t\t\t\tsuper.add(item);\n\t\t\t\tthis.#tracked_items.set(item, tracked(0, block));\n\t\t\t}\n\t\t}\n\n\t\tthis.#tracked_size = tracked(super.size, block);\n\n\t\tif (!init) {\n\t\t\tinit = true;\n\t\t\tthis.#init();\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\t#init() {\n\t\tvar proto = TrackedSet.prototype;\n\t\tvar set_proto = Set.prototype;\n\n\t\tfor (const method of introspect_methods) {\n\t\t\tif (!(method in set_proto)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n      /** @type {any} */ (proto)[method] = function (/** @type {...any} */ ...v) {\n\t\t\t\tthis.size;\n\n\t\t\t\treturn /** @type {any} */ (set_proto)[method].apply(this, v);\n\t\t\t};\n\t\t}\n\n\t\tfor (const method of compare_other_methods) {\n\t\t\tif (!(method in set_proto)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n      /** @type {any} */ (proto)[method] = function (/** @type {any} */ other, /** @type {...any} */ ...v) {\n\t\t\t\tthis.size;\n\n\t\t\t\tif (other instanceof TrackedSet) {\n\t\t\t\t\tother.size;\n\t\t\t\t}\n\n\t\t\t\treturn /** @type {any} */ (set_proto)[method].apply(this, [other, ...v]);\n\t\t\t};\n\t\t}\n\n\t\tfor (const method of new_other_methods) {\n\t\t\tif (!(method in set_proto)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n      /** @type {any} */ (proto)[method] = function (/** @type {any} */ other, /** @type {...any} */ ...v) {\n\t\t\t\tthis.size;\n\n\t\t\t\tif (other instanceof TrackedSet) {\n\t\t\t\t\tother.size;\n\t\t\t\t}\n\n\t\t\t\treturn new TrackedSet(/** @type {any} */(set_proto)[method].apply(this, [other, ...v]));\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * @param {T} value\n\t * @returns {this}\n\t */\n\tadd(value) {\n\t\tvar block = this.#block;\n\n\t\tif (!super.has(value)) {\n\t\t\tsuper.add(value);\n\t\t\tthis.#tracked_items.set(value, tracked(0, block));\n\t\t\tset(this.#tracked_size, super.size);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {T} value\n\t * @returns {boolean}\n\t */\n\tdelete(value) {\n\t\tvar block = this.#block;\n\n\t\tif (!super.delete(value)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar t = this.#tracked_items.get(value);\n\n\t\tif (t) {\n\t\t\tincrement(t);\n\t\t}\n\t\tthis.#tracked_items.delete(value);\n\t\tset(this.#tracked_size, super.size);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {T} value\n\t * @return {boolean}\n\t*/\n\thas(value) {\n\n\t\tvar has = super.has(value);\n\t\tvar tracked_items = this.#tracked_items;\n\t\tvar t = tracked_items.get(value);\n\n\t\tif (t === undefined) {\n\t\t\t// if no tracked it also means super didn't have it\n\t\t\t// It's not possible to have a disconnect, we track each value\n\t\t\t// If the value doesn't exist, track the size in case it's added later\n\t\t\t// but don't create tracked entries willy-nilly to track all possible values\n\t\t\tthis.size;\n\t\t} else {\n\t\t\tget(t);\n\t\t}\n\n\t\treturn has;\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tclear() {\n\t\tvar block = this.#block;\n\n\t\tif (super.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var [_, t] of this.#tracked_items) {\n\t\t\tincrement(t);\n\t\t}\n\n\t\tsuper.clear();\n\t\tthis.#tracked_items.clear();\n\t\tset(this.#tracked_size, 0);\n\t}\n\n\t/**\n\t * @returns {number}\n\t */\n\tget size() {\n\t\treturn get(this.#tracked_size);\n\t}\n\n\t/**\n\t * @returns {T[]}\n\t */\n\ttoJSON() {\n\t\tthis.size;\n\n\t\treturn [...this];\n\t}\n}\n\n/**\n * @template V\n * @param {Block} block\n * @param {...any} args\n * @returns {TrackedSet<V>}\n */\nexport function tracked_set(block, ...args) {\n\treturn with_scope(block, () => new TrackedSet(...args));\n}\n",
    "/** @import { Block, Tracked } from '#client' */\nimport { get, increment, safe_scope, set, tracked, with_scope } from './internal/client/runtime.js';\n\nconst introspect_methods = ['entries', 'forEach', 'values', Symbol.iterator];\n\nlet init = false;\n\n/**\n * @template K, V\n * @extends {Map<K, V>}\n * @returns {TrackedMap<K, V>}\n */\nexport class TrackedMap extends Map {\n\t/** @type {Tracked} */\n\t#tracked_size;\n\t/** @type {Map<K, Tracked>} */\n\t#tracked_items = new Map();\n\t/** @type {Block} */\n\t#block;\n\n\t/**\n\t * @param {Iterable<readonly [K, V]>} [iterable]\n\t */\n\tconstructor(iterable) {\n\t\tsuper();\n\n\t\tvar block = this.#block = safe_scope();\n\n\t\tif (iterable) {\n\t\t\tfor (var [key, value] of iterable) {\n\t\t\t\tsuper.set(key, value);\n\t\t\t\tthis.#tracked_items.set(key, tracked(0, block));\n\t\t\t}\n\t\t}\n\n\t\tthis.#tracked_size = tracked(super.size, block);\n\n\t\tif (!init) {\n\t\t\tinit = true;\n\t\t\tthis.#init();\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\t#init() {\n\t\tvar proto = TrackedMap.prototype;\n\t\tvar map_proto = Map.prototype;\n\n\t\tfor (const method of introspect_methods) {\n      /** @type {any} */ (proto)[method] = function (/** @type {...any} */ ...v) {\n\t\t\t\tthis.size;\n\t\t\t\tthis.#read_all();\n\n\t\t\t\treturn /** @type {any} */ (map_proto)[method].apply(this, v);\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * @param {K} key\n\t * @returns {V | undefined}\n\t */\n\tget(key) {\n\t\tvar tracked_items = this.#tracked_items;\n\t\tvar t = tracked_items.get(key);\n\n\t\tif (t === undefined) {\n\t\t\t// same logic as has\n\t\t\tthis.size;\n\t\t} else {\n\t\t\tget(t);\n\t\t}\n\n\t\treturn super.get(key);\n\t}\n\n\t/**\n\t * @param {K} key\n\t * @returns {boolean}\n\t */\n\thas(key) {\n\t\tvar has = super.has(key);\n\t\tvar tracked_items = this.#tracked_items;\n\t\tvar t = tracked_items.get(key);\n\n\t\tif (t === undefined) {\n\t\t\t// if no tracked it also means super didn't have it\n\t\t\t// It's not possible to have a disconnect, we tract each key\n\t\t\t// If the key doesn't exist, track the size in case it's added later\n\t\t\t// but don't create tracked entries willy-nilly to track all possible keys\n\t\t\tthis.size;\n\t\t} else {\n\t\t\tget(t);\n\t\t}\n\n\t\treturn has;\n\t}\n\n\t/**\n\t * @param {K} key\n\t * @param {V} value\n\t * @returns {this}\n\t */\n\tset(key, value) {\n\t\tvar block = this.#block;\n\t\tvar tracked_items = this.#tracked_items;\n\t\tvar t = tracked_items.get(key);\n\t\tvar prev_res = super.get(key);\n\n\t\tsuper.set(key, value);\n\n\t\tif (!t) {\n\t\t\ttracked_items.set(key, tracked(0, block));\n\t\t\tset(this.#tracked_size, super.size);\n\t\t} else if (prev_res !== value) {\n\t\t\tincrement(t);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {K} key\n\t * @returns {boolean}\n\t */\n\tdelete(key) {\n\t\tvar block = this.#block;\n\t\tvar tracked_items = this.#tracked_items;\n\t\tvar t = tracked_items.get(key);\n\t\tvar result = super.delete(key);\n\n\t\tif (t) {\n\t\t\tincrement(t);\n\t\t\ttracked_items.delete(key);\n\t\t\tset(this.#tracked_size, super.size);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tclear() {\n\t\tvar block = this.#block;\n\n\t\tif (super.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var [_, t] of this.#tracked_items) {\n\t\t\tincrement(t);\n\t\t}\n\n\t\tsuper.clear();\n\t\tthis.#tracked_items.clear();\n\t\tset(this.#tracked_size, 0);\n\t}\n\n\t/**\n\t * @returns {MapIterator<K>}\n\t */\n\tkeys() {\n\t\tthis.size;\n\t\treturn super.keys();\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\t#read_all() {\n\t\tfor (const [, t] of this.#tracked_items) {\n\t\t\tget(t);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {number}\n\t */\n\tget size() {\n\t\treturn get(this.#tracked_size);\n\t}\n\n\t/**\n\t * @returns {Array<[K, V]>}\n\t */\n\ttoJSON() {\n\t\tthis.size;\n\t\tthis.#read_all();\n\n\t\treturn [...this];\n\t}\n}\n\n/**\n * @template K, V\n * @param {Block} block\n * @param {...any} args\n * @returns {TrackedMap<K, V>}\n */\nexport function tracked_map(block, ...args) {\n\treturn with_scope(block, () => new TrackedMap(...args));\n}\n",
    "/** @import { Block, Derived } from '#client' */\nimport { safe_scope, tracked, get, derived, set } from './internal/client/runtime.js';\n\nvar init = false;\n\nexport class TrackedDate extends Date {\n\t#time;\n\t/** @type {Map<keyof Date, Derived>} */\n\t#deriveds = new Map();\n\t/** @type {Block} */\n\t#block;\n\n\t/** @param {any[]} params */\n\tconstructor(...params) {\n\t\t// @ts-ignore\n\t\tsuper(...params);\n\n\t\tvar block = this.#block = safe_scope();\n\t\tthis.#time = tracked(super.getTime(), block);\n\n\t\tif (!init) this.#init();\n\t}\n\n\t#init() {\n\t\tinit = true;\n\n\t\tvar proto = TrackedDate.prototype;\n\t\tvar date_proto = Date.prototype;\n\n\t\tvar methods = /** @type {Array<keyof Date & string>} */ (\n\t\t\tObject.getOwnPropertyNames(date_proto)\n\t\t);\n\n\t\tfor (const method of methods) {\n\t\t\tif (method.startsWith('get') || method.startsWith('to') || method === 'valueOf') {\n\t\t\t\t// @ts-ignore\n\t\t\t\tproto[method] = function (...args) {\n\t\t\t\t\t// don't memoize if there are arguments\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tif (args.length > 0) {\n\t\t\t\t\t\tget(this.#time);\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\treturn date_proto[method].apply(this, args);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar d = this.#deriveds.get(method);\n\n\t\t\t\t\tif (d === undefined) {\n\t\t\t\t\t\td = derived(() => {\n\t\t\t\t\t\t\tget(this.#time);\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn date_proto[method].apply(this, args);\n\t\t\t\t\t\t}, this.#block);\n\n\t\t\t\t\t\tthis.#deriveds.set(method, d);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn get(d);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (method.startsWith('set')) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tproto[method] = function (...args) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tvar result = date_proto[method].apply(this, args);\n\t\t\t\t\tset(this.#time, date_proto.getTime.call(this));\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "import { get, increment, safe_scope, tracked } from './internal/client/runtime.js';\nimport { get_current_url } from './url.js';\n\nexport const REPLACE = Symbol();\n\n\nexport class TrackedURLSearchParams extends URLSearchParams {\n\t#block = safe_scope();\n\t#version = tracked(0, this.#block);\n\t#url = get_current_url();\n\n\t#updating = false;\n\n\t#update_url() {\n\t\tif (!this.#url || this.#updating) return;\n\t\tthis.#updating = true;\n\n\t\tconst search = this.toString();\n\t\tthis.#url.search = search && `?${search}`;\n\n\t\tthis.#updating = false;\n\t}\n\n\t/**\n\t * @param {URLSearchParams} params\n\t * @internal\n\t */\n\t[REPLACE](params) {\n\t\tif (this.#updating) return;\n\t\tthis.#updating = true;\n\n\t\tfor (const key of [...super.keys()]) {\n\t\t\tsuper.delete(key);\n\t\t}\n\n\t\tfor (const [key, value] of params) {\n\t\t\tsuper.append(key, value);\n\t\t}\n\n\t\tincrement(this.#version);\n\t\tthis.#updating = false;\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {string} value\n\t * @returns {void}\n\t */\n\tappend(name, value) {\n\t\tsuper.append(name, value);\n\t\tthis.#update_url();\n\t\tincrement(this.#version);\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {string=} value\n\t * @returns {void}\n\t */\n\tdelete(name, value) {\n\t\tvar has_value = super.has(name, value);\n\t\tsuper.delete(name, value);\n\t\tif (has_value) {\n\t\t\tthis.#update_url();\n\t\t\tincrement(this.#version);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @returns {string|null}\n\t */\n\tget(name) {\n\t\tget(this.#version);\n\t\treturn super.get(name);\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @returns {string[]}\n\t */\n\tgetAll(name) {\n\t\tget(this.#version);\n\t\treturn super.getAll(name);\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {string=} value\n\t * @returns {boolean}\n\t */\n\thas(name, value) {\n\t\tget(this.#version);\n\t\treturn super.has(name, value);\n\t}\n\n\tkeys() {\n\t\tget(this.#version);\n\t\treturn super.keys();\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {string} value\n\t * @returns {void}\n\t */\n\tset(name, value) {\n\t\tvar previous = super.getAll(name).join('');\n\t\tsuper.set(name, value);\n\t\t// can't use has(name, value), because for something like https://svelte.dev?foo=1&bar=2&foo=3\n\t\t// if you set `foo` to 1, then foo=3 gets deleted whilst `has(\"foo\", \"1\")` returns true\n\t\tif (previous !== super.getAll(name).join('')) {\n\t\t\tthis.#update_url();\n\t\t\tincrement(this.#version);\n\t\t}\n\t}\n\n\tsort() {\n\t\tsuper.sort();\n\t\tthis.#update_url();\n\t\tincrement(this.#version);\n\t}\n\n\ttoString() {\n\t\tget(this.#version);\n\t\treturn super.toString();\n\t}\n\n\tvalues() {\n\t\tget(this.#version);\n\t\treturn super.values();\n\t}\n\n\tentries() {\n\t\tget(this.#version);\n\t\treturn super.entries();\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn this.entries();\n\t}\n\n\tget size() {\n\t\tget(this.#version);\n\t\treturn super.size;\n\t}\n}\n",
    "import { get, set, safe_scope, tracked } from './internal/client/runtime.js';\nimport { REPLACE, TrackedURLSearchParams } from './url-search-params.js';\n\n/** @type {TrackedURL | null} */\nlet current_url = null;\n\nexport function get_current_url() {\n\treturn current_url;\n}\n\nexport class TrackedURL extends URL {\n\t#block = safe_scope();\n\t#protocol = tracked(super.protocol, this.#block);\n\t#username = tracked(super.username, this.#block);\n\t#password = tracked(super.password, this.#block);\n\t#hostname = tracked(super.hostname, this.#block);\n\t#port = tracked(super.port, this.#block);\n\t#pathname = tracked(super.pathname, this.#block);\n\t#hash = tracked(super.hash, this.#block);\n\t#search = tracked(super.search, this.#block);\n\t#searchParams;\n\n\t/**\n\t * @param {string | URL} url\n\t * @param {string | URL} [base]\n\t */\n\tconstructor(url, base) {\n\t\turl = new URL(url, base);\n\t\tsuper(url);\n\n\t\tcurrent_url = this;\n\t\tthis.#searchParams = new TrackedURLSearchParams(url.searchParams);\n\t\tcurrent_url = null;\n\t}\n\n\tget hash() {\n\t\treturn get(this.#hash);\n\t}\n\n\tset hash(value) {\n\t\tsuper.hash = value;\n\t\tset(this.#hash, super.hash);\n\t}\n\n\tget host() {\n\t\tget(this.#hostname);\n\t\tget(this.#port);\n\t\treturn super.host;\n\t}\n\n\tset host(value) {\n\t\tsuper.host = value;\n\t\tset(this.#hostname, super.hostname);\n\t\tset(this.#port, super.port);\n\t}\n\n\tget hostname() {\n\t\treturn get(this.#hostname);\n\t}\n\n\tset hostname(value) {\n\t\tsuper.hostname = value;\n\t\tset(this.#hostname, super.hostname);\n\t}\n\n\tget href() {\n\t\tget(this.#protocol);\n\t\tget(this.#username);\n\t\tget(this.#password);\n\t\tget(this.#hostname);\n\t\tget(this.#port);\n\t\tget(this.#pathname);\n\t\tget(this.#hash);\n\t\tget(this.#search);\n\t\treturn super.href;\n\t}\n\n\tset href(value) {\n\t\tsuper.href = value;\n\t\tset(this.#protocol, super.protocol);\n\t\tset(this.#username, super.username);\n\t\tset(this.#password, super.password);\n\t\tset(this.#hostname, super.hostname);\n\t\tset(this.#port, super.port);\n\t\tset(this.#pathname, super.pathname);\n\t\tset(this.#hash, super.hash);\n\t\tset(this.#search, super.search);\n\t\tthis.#searchParams[REPLACE](super.searchParams);\n\t}\n\n\tget password() {\n\t\treturn get(this.#password);\n\t}\n\n\tset password(value) {\n\t\tsuper.password = value;\n\t\tset(this.#password, super.password);\n\t}\n\n\tget pathname() {\n\t\treturn get(this.#pathname);\n\t}\n\n\tset pathname(value) {\n\t\tsuper.pathname = value;\n\t\tset(this.#pathname, super.pathname);\n\t}\n\n\tget port() {\n\t\treturn get(this.#port);\n\t}\n\n\tset port(value) {\n\t\tsuper.port = value;\n\t\tset(this.#port, super.port);\n\t}\n\n\tget protocol() {\n\t\treturn get(this.#protocol);\n\t}\n\n\tset protocol(value) {\n\t\tsuper.protocol = value;\n\t\tset(this.#protocol, super.protocol);\n\t}\n\n\tget search() {\n\t\treturn get(this.#search);\n\t}\n\n\tset search(value) {\n\t\tsuper.search = value;\n\t\tset(this.#search, value);\n\t\tthis.#searchParams[REPLACE](super.searchParams);\n\t}\n\n\tget username() {\n\t\treturn get(this.#username);\n\t}\n\n\tset username(value) {\n\t\tsuper.username = value;\n\t\tset(this.#username, super.username);\n\t}\n\n\tget origin() {\n\t\tget(this.#protocol);\n\t\tget(this.#hostname);\n\t\tget(this.#port);\n\t\treturn super.origin;\n\t}\n\n\tget searchParams() {\n\t\treturn this.#searchParams;\n\t}\n\n\ttoString() {\n\t\treturn this.href;\n\t}\n\n\ttoJSON() {\n\t\treturn this.href;\n\t}\n}\n",
    "export const TEMPLATE_FRAGMENT = 1;\nexport const TEMPLATE_USE_IMPORT_NODE = 1 << 1;\nexport const IS_CONTROLLED = 1 << 2;\nexport const IS_INDEXED = 1 << 3;\nexport const TEMPLATE_SVG_NAMESPACE = 1 << 5;\nexport const TEMPLATE_MATHML_NAMESPACE = 1 << 6;\n",
    "/** @import { Block, Tracked } from '#client' */\n\nimport { IS_CONTROLLED, IS_INDEXED } from '../../../constants.js';\nimport { branch, destroy_block, destroy_block_children, render } from './blocks.js';\nimport { FOR_BLOCK, TRACKED_ARRAY } from './constants.js';\nimport { create_text, next_sibling } from './operations.js';\nimport { active_block, set, tracked, untrack } from './runtime.js';\nimport { array_from, is_array } from './utils.js';\n\n/**\n * @template V\n * @param {Node} anchor\n * @param {V} value\n * @param {number} index\n * @param {(anchor: Node, value: V | Tracked, index?: any) => Block} render_fn\n * @param {boolean} is_indexed\n * @param {boolean} is_keyed\n * @returns {Block}\n */\nfunction create_item(anchor, value, index, render_fn, is_indexed, is_keyed) {\n\tvar b = branch(() => {\n\t\tvar tracked_index;\n\t\t/** @type {V | Tracked} */\n\t\tvar tracked_value = value;\n\n\t\tif (is_indexed || is_keyed) {\n\t\t\tvar block = /** @type {Block} */ (active_block);\n\n\t\t\tif (block.s === null) {\n\t\t\t\tif (is_indexed) {\n\t\t\t\t\ttracked_index = tracked(index, block);\n\t\t\t\t}\n\t\t\t\tif (is_keyed) {\n\t\t\t\t\ttracked_value = tracked(value, block);\n\t\t\t\t}\n\n\t\t\t\tblock.s = {\n\t\t\t\t\tstart: null,\n\t\t\t\t\tend: null,\n\t\t\t\t\ti: tracked_index,\n\t\t\t\t\tv: tracked_value,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tif (is_indexed) {\n\t\t\t\t\ttracked_index = block.s.i;\n\t\t\t\t}\n\t\t\t\tif (is_keyed) {\n\t\t\t\t\ttracked_index = block.s.v;\n\t\t\t\t}\n\t\t\t}\n\t\t\trender_fn(anchor, tracked_value, tracked_index);\n\t\t} else {\n\t\t\trender_fn(anchor, tracked_value);\n\t\t}\n\t});\n\treturn b;\n}\n\n/**\n * @param {Block} block\n * @param {Element} anchor\n * @returns {void}\n */\nfunction move(block, anchor) {\n\tvar node = block.s.start;\n\tvar end = block.s.end;\n\n\tif (node === end) {\n\t\tanchor.before(node);\n\t\treturn;\n\t}\n\twhile (node !== null) {\n\t\tvar next_node = /** @type {Node} */ (next_sibling(node));\n\t\tanchor.before(node);\n\t\tnode = next_node;\n\t\tif (node === end) {\n\t\t\tanchor.before(end);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * @template V\n * @param {V[] | Iterable<V>} collection\n * @returns {V[]}\n */\nfunction collection_to_array(collection) {\n\tvar array = is_array(collection) ? collection : collection == null ? [] : array_from(collection);\n\n\t// If we are working with a tracked array, then we need to get a copy of\n\t// the elements, as the array itself is proxied, and not useful in diffing\n\tif (TRACKED_ARRAY in array) {\n\t\tarray = array_from(array);\n\t}\n\n\treturn array;\n}\n\n/**\n * @template V\n * @param {Element} node\n * @param {() => V[] | Iterable<V>} get_collection\n * @param {(anchor: Node, value: V | Tracked, index?: any) => Block} render_fn\n * @param {number} flags\n * @returns {void}\n */\nexport function for_block(node, get_collection, render_fn, flags) {\n\tvar is_controlled = (flags & IS_CONTROLLED) !== 0;\n\tvar is_indexed = (flags & IS_INDEXED) !== 0;\n\tvar anchor = /** @type {Element | Text} */ (node);\n\n\tif (is_controlled) {\n\t\tanchor = node.appendChild(create_text());\n\t}\n\n\trender(\n\t\t() => {\n\t\t\tvar block = /** @type {Block} */ (active_block);\n\t\t\tvar collection = get_collection();\n\t\t\tvar array = collection_to_array(collection);\n\n\t\t\tuntrack(() => {\n\t\t\t\treconcile_by_ref(anchor, block, array, render_fn, is_controlled, is_indexed);\n\t\t\t});\n\t\t},\n\t\tnull,\n\t\tFOR_BLOCK,\n\t);\n}\n\n/**\n * @template V\n * @template K\n * @param {Element} node\n * @param {() => V[] | Iterable<V>} get_collection\n * @param {(anchor: Node, value: V | Tracked, index?: any) => Block} render_fn\n * @param {number} flags\n * @param {(item: V) => K} [get_key]\n * @returns {void}\n */\nexport function for_block_keyed(node, get_collection, render_fn, flags, get_key) {\n\tvar is_controlled = (flags & IS_CONTROLLED) !== 0;\n\tvar is_indexed = (flags & IS_INDEXED) !== 0;\n\tvar anchor = /** @type {Element | Text} */ (node);\n\n\tif (is_controlled) {\n\t\tanchor = node.appendChild(create_text());\n\t}\n\n\trender(\n\t\t() => {\n\t\t\tvar block = /** @type {Block} */ (active_block);\n\t\t\tvar collection = get_collection();\n\t\t\tvar array = collection_to_array(collection);\n\n\t\t\tuntrack(() => {\n\t\t\t\treconcile_by_key(\n\t\t\t\t\tanchor,\n\t\t\t\t\tblock,\n\t\t\t\t\tarray,\n\t\t\t\t\trender_fn,\n\t\t\t\t\tis_controlled,\n\t\t\t\t\tis_indexed,\n\t\t\t\t\t/** @type {(item: V) => K} */ (get_key),\n\t\t\t\t);\n\t\t\t});\n\t\t},\n\t\tnull,\n\t\tFOR_BLOCK,\n\t);\n}\n\n/**\n * @template V\n * @param {Element | Text} anchor\n * @param {Block} block\n * @param {V[]} array\n * @returns {void}\n */\nfunction reconcile_fast_clear(anchor, block, array) {\n\tvar state = block.s;\n\tvar parent_node = /** @type {Element} */ (anchor.parentNode);\n\tparent_node.textContent = '';\n\tdestroy_block_children(block);\n\tparent_node.append(anchor);\n\tstate.array = array;\n\tstate.blocks = [];\n}\n\n/**\n * @param {Block} block\n * @param {number} index\n * @returns {void}\n */\nfunction update_index(block, index) {\n\tset(block.s.i, index);\n}\n\n/**\n * @param {Block} block\n * @param {any} value\n * @returns {void}\n */\nfunction update_value(block, value) {\n\tset(block.s.v, value);\n}\n\n/**\n * @template V\n * @template K\n * @param {Element | Text} anchor\n * @param {Block} block\n * @param {V[]} b\n * @param {(anchor: Node, value: V | Tracked, index?: any) => Block} render_fn\n * @param {boolean} is_controlled\n * @param {boolean} is_indexed\n * @param {(item: V) => K} get_key\n * @returns {void}\n */\nfunction reconcile_by_key(anchor, block, b, render_fn, is_controlled, is_indexed, get_key) {\n\tvar state = block.s;\n\n\t// Variables used in conditional branches - declare with initial values\n\t/** @type {number} */\n\tvar a_start = 0;\n\t/** @type {number} */\n\tvar b_start = 0;\n\t/** @type {number} */\n\tvar a_left = 0;\n\t/** @type {number} */\n\tvar b_left = 0;\n\t/** @type {Int32Array} */\n\tvar sources = new Int32Array(0);\n\t/** @type {boolean} */\n\tvar moved = false;\n\t/** @type {number} */\n\tvar pos = 0;\n\t/** @type {number} */\n\tvar patched = 0;\n\t/** @type {number} */\n\tvar i = 0;\n\n\tif (state === null) {\n\t\tstate = block.s = {\n\t\t\tarray: [],\n\t\t\tblocks: [],\n\t\t\tkeys: null,\n\t\t};\n\t}\n\n\tvar a = state.array;\n\tvar a_length = a.length;\n\tvar b_length = b.length;\n\tvar j = 0;\n\n\t// Fast-path for clear\n\tif (is_controlled && b_length === 0) {\n\t\tif (a_length > 0) {\n\t\t\treconcile_fast_clear(anchor, block, b);\n\t\t}\n\t\treturn;\n\t}\n\tvar b_blocks = Array(b_length);\n\tvar b_keys = b.map(get_key);\n\n\t// Fast-path for create\n\tif (a_length === 0) {\n\t\tfor (; j < b_length; j++) {\n\t\t\tb_blocks[j] = create_item(anchor, b[j], j, render_fn, is_indexed, true);\n\t\t}\n\t\tstate.array = b;\n\t\tstate.blocks = b_blocks;\n\t\tstate.keys = b_keys;\n\t\treturn;\n\t}\n\n\tvar a_blocks = state.blocks;\n\tvar a_keys = state.keys;\n\tvar a_val = a[j];\n\tvar b_val = b[j];\n\tvar a_key = a_keys[j];\n\tvar b_key = b_keys[j];\n\tvar a_end = a_length - 1;\n\tvar b_end = b_length - 1;\n\tvar b_block;\n\n\touter: {\n\t\twhile (a_key === b_key) {\n\t\t\ta[j] = b_val;\n\t\t\tb_block = b_blocks[j] = a_blocks[j];\n\t\t\tif (is_indexed) {\n\t\t\t\tupdate_index(b_block, j);\n\t\t\t}\n\t\t\tupdate_value(b_block, b_val);\n\t\t\t++j;\n\t\t\tif (j > a_end || j > b_end) {\n\t\t\t\tbreak outer;\n\t\t\t}\n\t\t\ta_val = a[j];\n\t\t\tb_val = b[j];\n\t\t\ta_key = a_keys[j];\n\t\t\tb_key = b_keys[j];\n\t\t}\n\n\t\ta_val = a[a_end];\n\t\tb_val = b[b_end];\n\t\ta_key = a_keys[a_end];\n\t\tb_key = b_keys[b_end];\n\n\t\twhile (a_key === b_key) {\n\t\t\ta[a_end] = b_val;\n\t\t\tb_block = b_blocks[b_end] = a_blocks[a_end];\n\t\t\tif (is_indexed) {\n\t\t\t\tupdate_index(b_block, b_end);\n\t\t\t}\n\t\t\tupdate_value(b_block, b_val);\n\t\t\ta_end--;\n\t\t\tb_end--;\n\t\t\tif (j > a_end || j > b_end) {\n\t\t\t\tbreak outer;\n\t\t\t}\n\t\t\ta_val = a[a_end];\n\t\t\tb_val = b[b_end];\n\t\t\ta_key = a_keys[a_end];\n\t\t\tb_key = b_keys[b_end];\n\t\t}\n\t}\n\n\tvar fast_path_removal = false;\n\n\tif (j > a_end) {\n\t\tif (j <= b_end) {\n\t\t\twhile (j <= b_end) {\n\t\t\t\tb_val = b[j];\n\t\t\t\tvar target = j >= a_length ? anchor : a_blocks[j].s.start;\n\t\t\t\tb_blocks[j] = create_item(target, b_val, j, render_fn, is_indexed, true);\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t} else if (j > b_end) {\n\t\twhile (j <= a_end) {\n\t\t\tdestroy_block(a_blocks[j++]);\n\t\t}\n\t} else {\n\t\ta_start = j;\n\t\tb_start = j;\n\t\ta_left = a_end - j + 1;\n\t\tb_left = b_end - j + 1;\n\t\tsources = new Int32Array(b_left + 1);\n\t\tmoved = false;\n\t\tpos = 0;\n\t\tpatched = 0;\n\t\ti = 0;\n\n\t\tfast_path_removal = is_controlled && a_left === a_length;\n\n\t\t// When sizes are small, just loop them through\n\t\tif (b_length < 4 || (a_left | b_left) < 32) {\n\t\t\tfor (i = a_start; i <= a_end; ++i) {\n\t\t\t\ta_val = a[i];\n\t\t\t\ta_key = a_keys[i];\n\t\t\t\tif (patched < b_left) {\n\t\t\t\t\tfor (j = b_start; j <= b_end; j++) {\n\t\t\t\t\t\tb_val = b[j];\n\t\t\t\t\t\tb_key = b_keys[j];\n\t\t\t\t\t\tif (a_key === b_key) {\n\t\t\t\t\t\t\tsources[j - b_start] = i + 1;\n\t\t\t\t\t\t\tif (fast_path_removal) {\n\t\t\t\t\t\t\t\tfast_path_removal = false;\n\t\t\t\t\t\t\t\twhile (a_start < i) {\n\t\t\t\t\t\t\t\t\tdestroy_block(a_blocks[a_start++]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (pos > j) {\n\t\t\t\t\t\t\t\tmoved = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tb_block = b_blocks[j] = a_blocks[i];\n\t\t\t\t\t\t\tif (is_indexed) {\n\t\t\t\t\t\t\t\tupdate_index(b_block, j);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tupdate_value(b_block, b_val);\n\t\t\t\t\t\t\t++patched;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!fast_path_removal && j > b_end) {\n\t\t\t\t\t\tdestroy_block(a_blocks[i]);\n\t\t\t\t\t}\n\t\t\t\t} else if (!fast_path_removal) {\n\t\t\t\t\tdestroy_block(a_blocks[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar map = new Map();\n\n\t\t\tfor (i = b_start; i <= b_end; ++i) {\n\t\t\t\tmap.set(b_keys[i], i);\n\t\t\t}\n\n\t\t\tfor (i = a_start; i <= a_end; ++i) {\n\t\t\t\ta_val = a[i];\n\t\t\t\ta_key = a_keys[i];\n\n\t\t\t\tif (patched < b_left) {\n\t\t\t\t\tj = map.get(a_key);\n\n\t\t\t\t\tif (j !== undefined) {\n\t\t\t\t\t\tif (fast_path_removal) {\n\t\t\t\t\t\t\tfast_path_removal = false;\n\t\t\t\t\t\t\twhile (i > a_start) {\n\t\t\t\t\t\t\t\tdestroy_block(a[a_start++]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsources[j - b_start] = i + 1;\n\t\t\t\t\t\tif (pos > j) {\n\t\t\t\t\t\t\tmoved = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tblock = b_blocks[j] = a_blocks[i];\n\t\t\t\t\t\tb_val = b[j];\n\t\t\t\t\t\tif (is_indexed) {\n\t\t\t\t\t\t\tupdate_index(block, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tupdate_value(b_block, b_val);\n\t\t\t\t\t\t++patched;\n\t\t\t\t\t} else if (!fast_path_removal) {\n\t\t\t\t\t\tdestroy_block(a_blocks[i]);\n\t\t\t\t\t}\n\t\t\t\t} else if (!fast_path_removal) {\n\t\t\t\t\tdestroy_block(a_blocks[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (fast_path_removal) {\n\t\treconcile_fast_clear(anchor, block, []);\n\t\treconcile_by_key(anchor, block, b, render_fn, is_controlled, is_indexed, get_key);\n\t\treturn;\n\t} else if (moved) {\n\t\tvar next_pos = 0;\n\t\tvar seq = lis_algorithm(sources);\n\t\tj = seq.length - 1;\n\n\t\tfor (i = b_left - 1; i >= 0; i--) {\n\t\t\tif (sources[i] === 0) {\n\t\t\t\tpos = i + b_start;\n\t\t\t\tb_val = b[pos];\n\t\t\t\tnext_pos = pos + 1;\n\n\t\t\t\tvar target = next_pos < b_length ? b_blocks[next_pos].s.start : anchor;\n\t\t\t\tb_blocks[pos] = create_item(target, b_val, pos, render_fn, is_indexed, true);\n\t\t\t} else if (j < 0 || i !== seq[j]) {\n\t\t\t\tpos = i + b_start;\n\t\t\t\tb_val = b[pos];\n\t\t\t\tnext_pos = pos + 1;\n\n\t\t\t\tvar target = next_pos < b_length ? b_blocks[next_pos].s.start : anchor;\n\t\t\t\tmove(b_blocks[pos], target);\n\t\t\t} else {\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t} else if (patched !== b_left) {\n\t\tfor (i = b_left - 1; i >= 0; i--) {\n\t\t\tif (sources[i] === 0) {\n\t\t\t\tpos = i + b_start;\n\t\t\t\tb_val = b[pos];\n\t\t\t\tnext_pos = pos + 1;\n\n\t\t\t\tvar target = next_pos < b_length ? b_blocks[next_pos].s.start : anchor;\n\t\t\t\tb_blocks[pos] = create_item(target, b_val, pos, render_fn, is_indexed, true);\n\t\t\t}\n\t\t}\n\t}\n\n\tstate.array = b;\n\tstate.blocks = b_blocks;\n\tstate.keys = b_keys;\n}\n\n/**\n * @template V\n * @param {Element | Text} anchor\n * @param {Block} block\n * @param {V[]} b\n * @param {(anchor: Node, value: V | Tracked, index?: any) => Block} render_fn\n * @param {boolean} is_controlled\n * @param {boolean} is_indexed\n * @returns {void}\n */\nfunction reconcile_by_ref(anchor, block, b, render_fn, is_controlled, is_indexed) {\n\tvar state = block.s;\n\n\t// Variables used in conditional branches - declare with initial values\n\t/** @type {number} */\n\tvar a_start = 0;\n\t/** @type {number} */\n\tvar b_start = 0;\n\t/** @type {number} */\n\tvar a_left = 0;\n\t/** @type {number} */\n\tvar b_left = 0;\n\t/** @type {Int32Array} */\n\tvar sources = new Int32Array(0);\n\t/** @type {boolean} */\n\tvar moved = false;\n\t/** @type {number} */\n\tvar pos = 0;\n\t/** @type {number} */\n\tvar patched = 0;\n\t/** @type {number} */\n\tvar i = 0;\n\n\tif (state === null) {\n\t\tstate = block.s = {\n\t\t\tarray: [],\n\t\t\tblocks: [],\n\t\t\tkeys: null,\n\t\t};\n\t}\n\n\tvar a = state.array;\n\tvar a_length = a.length;\n\tvar b_length = b.length;\n\tvar j = 0;\n\n\t// Fast-path for clear\n\tif (is_controlled && b_length === 0) {\n\t\tif (a_length > 0) {\n\t\t\treconcile_fast_clear(anchor, block, b);\n\t\t}\n\t\treturn;\n\t}\n\tvar b_blocks = Array(b_length);\n\n\t// Fast-path for create\n\tif (a_length === 0) {\n\t\tfor (; j < b_length; j++) {\n\t\t\tb_blocks[j] = create_item(anchor, b[j], j, render_fn, is_indexed, false);\n\t\t}\n\t\tstate.array = b;\n\t\tstate.blocks = b_blocks;\n\t\treturn;\n\t}\n\n\tvar a_blocks = state.blocks;\n\tvar a_val = a[j];\n\tvar b_val = b[j];\n\tvar a_end = a_length - 1;\n\tvar b_end = b_length - 1;\n\tvar b_block;\n\n\touter: {\n\t\twhile (a_val === b_val) {\n\t\t\ta[j] = b_val;\n\t\t\tb_block = b_blocks[j] = a_blocks[j];\n\t\t\tif (is_indexed) {\n\t\t\t\tupdate_index(b_block, j);\n\t\t\t}\n\t\t\t++j;\n\t\t\tif (j > a_end || j > b_end) {\n\t\t\t\tbreak outer;\n\t\t\t}\n\t\t\ta_val = a[j];\n\t\t\tb_val = b[j];\n\t\t}\n\n\t\ta_val = a[a_end];\n\t\tb_val = b[b_end];\n\n\t\twhile (a_val === b_val) {\n\t\t\ta[a_end] = b_val;\n\t\t\tb_block = b_blocks[b_end] = a_blocks[a_end];\n\t\t\tif (is_indexed) {\n\t\t\t\tupdate_index(b_block, b_end);\n\t\t\t}\n\t\t\ta_end--;\n\t\t\tb_end--;\n\t\t\tif (j > a_end || j > b_end) {\n\t\t\t\tbreak outer;\n\t\t\t}\n\t\t\ta_val = a[a_end];\n\t\t\tb_val = b[b_end];\n\t\t}\n\t}\n\n\tvar fast_path_removal = false;\n\n\tif (j > a_end) {\n\t\tif (j <= b_end) {\n\t\t\twhile (j <= b_end) {\n\t\t\t\tb_val = b[j];\n\t\t\t\tvar target = j >= a_length ? anchor : a_blocks[j].s.start;\n\t\t\t\tb_blocks[j] = create_item(target, b_val, j, render_fn, is_indexed, false);\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t} else if (j > b_end) {\n\t\twhile (j <= a_end) {\n\t\t\tdestroy_block(a_blocks[j++]);\n\t\t}\n\t} else {\n\t\ta_start = j;\n\t\tb_start = j;\n\t\ta_left = a_end - j + 1;\n\t\tb_left = b_end - j + 1;\n\t\tsources = new Int32Array(b_left + 1);\n\t\tmoved = false;\n\t\tpos = 0;\n\t\tpatched = 0;\n\t\ti = 0;\n\n\t\tfast_path_removal = is_controlled && a_left === a_length;\n\n\t\t// When sizes are small, just loop them through\n\t\tif (b_length < 4 || (a_left | b_left) < 32) {\n\t\t\tfor (i = a_start; i <= a_end; ++i) {\n\t\t\t\ta_val = a[i];\n\t\t\t\tif (patched < b_left) {\n\t\t\t\t\tfor (j = b_start; j <= b_end; j++) {\n\t\t\t\t\t\tb_val = b[j];\n\t\t\t\t\t\tif (a_val === b_val) {\n\t\t\t\t\t\t\tsources[j - b_start] = i + 1;\n\t\t\t\t\t\t\tif (fast_path_removal) {\n\t\t\t\t\t\t\t\tfast_path_removal = false;\n\t\t\t\t\t\t\t\twhile (a_start < i) {\n\t\t\t\t\t\t\t\t\tdestroy_block(a_blocks[a_start++]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (pos > j) {\n\t\t\t\t\t\t\t\tmoved = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tb_block = b_blocks[j] = a_blocks[i];\n\t\t\t\t\t\t\tif (is_indexed) {\n\t\t\t\t\t\t\t\tupdate_index(b_block, j);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++patched;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!fast_path_removal && j > b_end) {\n\t\t\t\t\t\tdestroy_block(a_blocks[i]);\n\t\t\t\t\t}\n\t\t\t\t} else if (!fast_path_removal) {\n\t\t\t\t\tdestroy_block(a_blocks[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar map = new Map();\n\n\t\t\tfor (i = b_start; i <= b_end; ++i) {\n\t\t\t\tmap.set(b[i], i);\n\t\t\t}\n\n\t\t\tfor (i = a_start; i <= a_end; ++i) {\n\t\t\t\ta_val = a[i];\n\n\t\t\t\tif (patched < b_left) {\n\t\t\t\t\tj = map.get(a_val);\n\n\t\t\t\t\tif (j !== undefined) {\n\t\t\t\t\t\tif (fast_path_removal) {\n\t\t\t\t\t\t\tfast_path_removal = false;\n\t\t\t\t\t\t\twhile (i > a_start) {\n\t\t\t\t\t\t\t\tdestroy_block(a[a_start++]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsources[j - b_start] = i + 1;\n\t\t\t\t\t\tif (pos > j) {\n\t\t\t\t\t\t\tmoved = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tblock = b_blocks[j] = a_blocks[i];\n\t\t\t\t\t\tif (is_indexed) {\n\t\t\t\t\t\t\tupdate_index(block, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++patched;\n\t\t\t\t\t} else if (!fast_path_removal) {\n\t\t\t\t\t\tdestroy_block(a_blocks[i]);\n\t\t\t\t\t}\n\t\t\t\t} else if (!fast_path_removal) {\n\t\t\t\t\tdestroy_block(a_blocks[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (fast_path_removal) {\n\t\treconcile_fast_clear(anchor, block, []);\n\t\treconcile_by_ref(anchor, block, b, render_fn, is_controlled, is_indexed);\n\t\treturn;\n\t} else if (moved) {\n\t\tvar next_pos = 0;\n\t\tvar seq = lis_algorithm(sources);\n\t\tj = seq.length - 1;\n\n\t\tfor (i = b_left - 1; i >= 0; i--) {\n\t\t\tif (sources[i] === 0) {\n\t\t\t\tpos = i + b_start;\n\t\t\t\tb_val = b[pos];\n\t\t\t\tnext_pos = pos + 1;\n\n\t\t\t\tvar target = next_pos < b_length ? b_blocks[next_pos].s.start : anchor;\n\t\t\t\tb_blocks[pos] = create_item(target, b_val, pos, render_fn, is_indexed, false);\n\t\t\t} else if (j < 0 || i !== seq[j]) {\n\t\t\t\tpos = i + b_start;\n\t\t\t\tb_val = b[pos];\n\t\t\t\tnext_pos = pos + 1;\n\n\t\t\t\tvar target = next_pos < b_length ? b_blocks[next_pos].s.start : anchor;\n\t\t\t\tmove(b_blocks[pos], target);\n\t\t\t} else {\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t} else if (patched !== b_left) {\n\t\tfor (i = b_left - 1; i >= 0; i--) {\n\t\t\tif (sources[i] === 0) {\n\t\t\t\tpos = i + b_start;\n\t\t\t\tb_val = b[pos];\n\t\t\t\tnext_pos = pos + 1;\n\n\t\t\t\tvar target = next_pos < b_length ? b_blocks[next_pos].s.start : anchor;\n\t\t\t\tb_blocks[pos] = create_item(target, b_val, pos, render_fn, is_indexed, false);\n\t\t\t}\n\t\t}\n\t}\n\n\tstate.array = b;\n\tstate.blocks = b_blocks;\n}\n\n/** @type {Int32Array} */\nlet result;\n/** @type {Int32Array} */\nlet p;\nlet max_len = 0;\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\n/**\n * @param {Int32Array} arr\n * @returns {Int32Array}\n */\nfunction lis_algorithm(arr) {\n\tlet arrI = 0;\n\tlet i = 0;\n\tlet j = 0;\n\tlet k = 0;\n\tlet u = 0;\n\tlet v = 0;\n\tlet c = 0;\n\tvar len = arr.length;\n\n\tif (len > max_len) {\n\t\tmax_len = len;\n\t\tresult = new Int32Array(len);\n\t\tp = new Int32Array(len);\n\t}\n\n\tfor (; i < len; ++i) {\n\t\tarrI = arr[i];\n\n\t\tif (arrI !== 0) {\n\t\t\tj = result[k];\n\t\t\tif (arr[j] < arrI) {\n\t\t\t\tp[i] = j;\n\t\t\t\tresult[++k] = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tu = 0;\n\t\t\tv = k;\n\n\t\t\twhile (u < v) {\n\t\t\t\tc = (u + v) >> 1;\n\t\t\t\tif (arr[result[c]] < arrI) {\n\t\t\t\t\tu = c + 1;\n\t\t\t\t} else {\n\t\t\t\t\tv = c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (arrI < arr[result[u]]) {\n\t\t\t\tif (u > 0) {\n\t\t\t\t\tp[i] = result[u - 1];\n\t\t\t\t}\n\t\t\t\tresult[u] = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tu = k + 1;\n\tvar seq = new Int32Array(u);\n\tv = result[u - 1];\n\n\twhile (u-- > 0) {\n\t\tseq[u] = v;\n\t\tv = p[v];\n\t\tresult[u] = 0;\n\t}\n\n\treturn seq;\n}\n",
    "/** @import { Block } from '#client' */\n\nimport {\n\tTEMPLATE_FRAGMENT,\n\tTEMPLATE_USE_IMPORT_NODE,\n\tTEMPLATE_SVG_NAMESPACE,\n\tTEMPLATE_MATHML_NAMESPACE,\n} from '../../../constants.js';\nimport { first_child, is_firefox } from './operations.js';\nimport { active_block, active_namespace } from './runtime.js';\n\n/**\n * Assigns start and end nodes to the active block's state.\n * @param {Node} start - The start node.\n * @param {Node} end - The end node.\n */\nexport function assign_nodes(start, end) {\n\tvar block = /** @type {Block} */ (active_block);\n\tvar s = block.s;\n\tif (s === null) {\n\t\tblock.s = {\n\t\t\tstart,\n\t\t\tend,\n\t\t};\n\t} else if (s.start === null) {\n\t\ts.start = start;\n\t\ts.end = end;\n\t}\n}\n\n/**\n * Creates a DocumentFragment from an HTML string.\n * @param {string} html - The HTML string.\n * @param {boolean} use_svg_namespace - Whether to use SVG namespace.\n * @param {boolean} use_mathml_namespace - Whether to use MathML namespace.\n * @returns {DocumentFragment}\n */\nexport function create_fragment_from_html(\n\thtml,\n\tuse_svg_namespace = false,\n\tuse_mathml_namespace = false,\n) {\n\tif (use_svg_namespace) {\n\t\treturn from_namespace(html, 'svg');\n\t}\n\tif (use_mathml_namespace) {\n\t\treturn from_namespace(html, 'math');\n\t}\n\tvar elem = document.createElement('template');\n\telem.innerHTML = html;\n\treturn elem.content;\n}\n\n/**\n * Creates a template node or fragment from content and flags.\n * @param {string} content - The template content.\n * @param {number} flags - Flags for template type.\n * @returns {() => Node}\n */\nexport function template(content, flags) {\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;\n\tvar use_svg_namespace = (flags & TEMPLATE_SVG_NAMESPACE) !== 0;\n\tvar use_mathml_namespace = (flags & TEMPLATE_MATHML_NAMESPACE) !== 0;\n\t/** @type {Node | DocumentFragment | undefined} */\n\tvar node;\n\tvar is_comment = content === '<!>';\n\tvar has_start = !is_comment && !content.startsWith('<!>');\n\n\treturn () => {\n\t\t// If using runtime namespace, check active_namespace\n\t\tvar svg = !is_comment && (use_svg_namespace || active_namespace === 'svg');\n\t\tvar mathml = !is_comment && (use_mathml_namespace || active_namespace === 'mathml');\n\n\t\tif (node === undefined) {\n\t\t\tnode = create_fragment_from_html(has_start ? content : '<!>' + content, svg, mathml);\n\t\t\tif (!is_fragment) node = /** @type {Node} */ (first_child(node));\n\t\t}\n\n\t\tvar clone =\n\t\t\tuse_import_node || is_firefox\n\t\t\t\t? document.importNode(/** @type {Node} */ (node), true)\n\t\t\t\t: /** @type {Node} */ (node).cloneNode(true);\n\n\t\tif (is_fragment) {\n\t\t\tvar start = first_child(clone);\n\t\t\tvar end = clone.lastChild;\n\n\t\t\tassign_nodes(/** @type {Node} */ (start), /** @type {Node} */ (end));\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * Appends a DOM node before the anchor node.\n * @param {ChildNode} anchor - The anchor node.\n * @param {Node} dom - The DOM node to append.\n */\nexport function append(anchor, dom) {\n\tanchor.before(/** @type {Node} */ (dom));\n}\n\n/**\n * Create fragment with proper namespace using Svelte's wrapping approach\n * @param {string} content\n * @param {'svg' | 'math'} ns\n * @returns {DocumentFragment}\n */\nfunction from_namespace(content, ns = 'svg') {\n\tvar wrapped = `<${ns}>${content}</${ns}>`;\n\n\tvar elem = document.createElement('template');\n\telem.innerHTML = wrapped;\n\tvar fragment = elem.content;\n\n\tvar root = /** @type {Element} */ (first_child(fragment));\n\tvar result = document.createDocumentFragment();\n\n\tvar first;\n\twhile ((first = first_child(root))) {\n\t\tresult.appendChild(/** @type {Node} */ (first));\n\t}\n\n\treturn result;\n}\n",
    "import { on } from './internal/client/events.js';\nimport { get, safe_scope, set, tracked } from './internal/client/index.js';\nimport { ReactiveValue } from './reactive-value.js';\n\nconst parenthesis_regex = /\\(.+\\)/;\nconst non_parenthesized_keywords = new Set(['all', 'print', 'screen', 'and', 'or', 'not', 'only']);\n\n/**\n * @constructor\n * @param {string} query\n * @param {boolean | undefined} [fallback]\n * @returns {ReactiveValue<boolean>}\n */\nexport function MediaQuery(query, fallback) {\n\tif (!new.target) {\n\t\tthrow new TypeError('MediaQuery must be called with new');\n\t}\n\n\tvar block = safe_scope();\n\n\tlet final_query =\n\t\tparenthesis_regex.test(query) ||\n\t\t// we need to use `some` here because technically this `window.matchMedia('random,screen')` still returns true\n\t\tquery.split(/[\\s,]+/).some((keyword) => non_parenthesized_keywords.has(keyword.trim()))\n\t\t\t? query\n\t\t\t: `(${query})`;\n\tconst q = window.matchMedia(final_query);\n\tconst matches = tracked(q.matches, block);\n\n\treturn new ReactiveValue(\n\t\t() => get(matches),\n\t\t() =>\n\t\t\ton(\n\t\t\t\tq,\n\t\t\t\t'change',\n\t\t\t\t() => {\n\t\t\t\t\t// skip wrapping in untrack as createSubscriber already does it\n\t\t\t\t\tif (q.matches !== get(matches)) {\n\t\t\t\t\t\tset(matches, q.matches);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{ delegated: false },\n\t\t\t),\n\t);\n}\n",
    "/** @import { Tracked } from '#client' */\n\n/**\n@typedef {(v: unknown) => void} SetFunction\n@typedef {() => any} BindGetter\n@typedef {(v: unknown) => void} BindSetter\n@typedef {{getter: BindGetter, setter: BindSetter}} BindGetSet\n*/\n\nimport { effect, render } from './blocks.js';\nimport { on } from './events.js';\nimport { get, set, tick, untrack } from './runtime.js';\nimport { is_array, is_tracked_object } from './utils.js';\n\n/**\n * @param {string} name\n * @returns {TypeError}\n */\nfunction not_tracked_type_error(name) {\n\treturn new TypeError(`${name} argument is not a tracked object`);\n}\n\n/**\n * @param {string} name\n * @returns {TypeError}\n */\nfunction not_set_function_type_error(name) {\n\treturn new TypeError(\n\t\t`${name} second argument must be a set function when first argument is a get function`,\n\t);\n}\n\n/**\n * @param {string} name\n * @param {unknown} maybe_tracked\n * @param {SetFunction | undefined} set_func\n * @returns {BindGetSet}\n */\nfunction get_bind_get_set(name, maybe_tracked, set_func) {\n\tif (typeof maybe_tracked === 'function') {\n\t\tif (typeof set_func !== 'function') {\n\t\t\tthrow not_set_function_type_error(name);\n\t\t}\n\n\t\treturn {\n\t\t\tgetter: /** @type {BindGetter} */ (maybe_tracked),\n\t\t\tsetter: set_func,\n\t\t};\n\t} else {\n\t\tif (!is_tracked_object(maybe_tracked)) {\n\t\t\tthrow not_tracked_type_error(name);\n\t\t}\n\n\t\treturn {\n\t\t\tgetter: () => get(/** @type {Tracked} */ (maybe_tracked)),\n\t\t\tsetter: (value) => set(/** @type {Tracked} */ (maybe_tracked), value),\n\t\t};\n\t}\n}\n\n/**\n * Resize observer singleton.\n * One listener per element only!\n * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ\n */\nclass ResizeObserverSingleton {\n\t/** */\n\t#listeners = new WeakMap();\n\n\t/** @type {ResizeObserver | undefined} */\n\t#observer;\n\n\t/** @type {ResizeObserverOptions} */\n\t#options;\n\n\t/** @static */\n\tstatic entries = new WeakMap();\n\n\t/** @param {ResizeObserverOptions} options */\n\tconstructor(options) {\n\t\tthis.#options = options;\n\t}\n\n\t/**\n\t * @param {Element} element\n\t * @param {(entry: ResizeObserverEntry) => any} listener\n\t */\n\tobserve(element, listener) {\n\t\tvar listeners = this.#listeners.get(element) || new Set();\n\t\tlisteners.add(listener);\n\n\t\tthis.#listeners.set(element, listeners);\n\t\tthis.#getObserver().observe(element, this.#options);\n\n\t\treturn () => {\n\t\t\tvar listeners = this.#listeners.get(element);\n\t\t\tlisteners.delete(listener);\n\n\t\t\tif (listeners.size === 0) {\n\t\t\t\tthis.#listeners.delete(element);\n\t\t\t\t/** @type {ResizeObserver} */ (this.#observer).unobserve(element);\n\t\t\t}\n\t\t};\n\t}\n\n\t#getObserver() {\n\t\treturn (\n\t\t\tthis.#observer ??\n\t\t\t(this.#observer = new ResizeObserver(\n\t\t\t\t/** @param {any} entries */ (entries) => {\n\t\t\t\t\tfor (var entry of entries) {\n\t\t\t\t\t\tResizeObserverSingleton.entries.set(entry.target, entry);\n\t\t\t\t\t\tfor (var listener of this.#listeners.get(entry.target) || []) {\n\t\t\t\t\t\t\tlistener(entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t))\n\t\t);\n\t}\n}\n\nvar resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'content-box',\n});\n\nvar resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'border-box',\n});\n\nvar resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'device-pixel-content-box',\n});\n\n/**\n * @param {string} value\n */\nfunction to_number(value) {\n\treturn value === '' ? null : +value;\n}\n\n/**\n * @param {HTMLInputElement} input\n */\nfunction is_numberlike_input(input) {\n\tvar type = input.type;\n\treturn type === 'number' || type === 'range';\n}\n\n/** @param {HTMLOptionElement} option */\nfunction get_option_value(option) {\n\treturn option.value;\n}\n\n/**\n * Selects the correct option(s) (depending on whether this is a multiple select)\n * @template V\n * @param {HTMLSelectElement} select\n * @param {V} value\n * @param {boolean} mounting\n */\nfunction select_option(select, value, mounting = false) {\n\tif (select.multiple) {\n\t\t// If value is null or undefined, keep the selection as is\n\t\tif (value == undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If not an array, warn and keep the selection as is\n\t\tif (!is_array(value)) {\n\t\t\t// TODO\n\t\t}\n\n\t\t// Otherwise, update the selection\n\t\tfor (var option of select.options) {\n\t\t\toption.selected = /** @type {string[]} */ (value).includes(get_option_value(option));\n\t\t}\n\n\t\treturn;\n\t}\n\n\tfor (option of select.options) {\n\t\tvar option_value = get_option_value(option);\n\t\tif (option_value === value) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {SetFunction | undefined} set_func\n * @returns {(node: HTMLInputElement | HTMLSelectElement) => void}\n */\nexport function bindValue(maybe_tracked, set_func = undefined) {\n\tvar { getter, setter } = get_bind_get_set('bindValue()', maybe_tracked, set_func);\n\n\treturn (node) => {\n\t\tvar clear_event;\n\n\t\tif (node.tagName === 'SELECT') {\n\t\t\tvar select = /** @type {HTMLSelectElement} */ (node);\n\t\t\tvar mounting = true;\n\n\t\t\tclear_event = on(select, 'change', async () => {\n\t\t\t\tvar query = ':checked';\n\t\t\t\t/** @type {unknown} */\n\t\t\t\tvar value;\n\n\t\t\t\tif (select.multiple) {\n\t\t\t\t\tvalue = [].map.call(select.querySelectorAll(query), get_option_value);\n\t\t\t\t} else {\n\t\t\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tvar selected_option =\n\t\t\t\t\t\tselect.querySelector(query) ??\n\t\t\t\t\t\t// will fall back to first non-disabled option if no option is selected\n\t\t\t\t\t\tselect.querySelector('option:not([disabled])');\n\t\t\t\t\tvalue = selected_option && get_option_value(selected_option);\n\t\t\t\t}\n\n\t\t\t\tsetter(value);\n\t\t\t});\n\n\t\t\teffect(() => {\n\t\t\t\tvar value = getter();\n\t\t\t\tselect_option(select, value, mounting);\n\n\t\t\t\t// Mounting and value undefined -> take selection from dom\n\t\t\t\tif (mounting && value === undefined) {\n\t\t\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tvar selected_option = select.querySelector(':checked');\n\t\t\t\t\tif (selected_option !== null) {\n\t\t\t\t\t\tvalue = get_option_value(selected_option);\n\t\t\t\t\t\tsetter(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmounting = false;\n\t\t\t});\n\t\t} else {\n\t\t\tvar input = /** @type {HTMLInputElement} */ (node);\n\n\t\t\tclear_event = on(input, 'input', async () => {\n\t\t\t\t/** @type {any} */\n\t\t\t\tvar value = input.value;\n\t\t\t\tvalue = is_numberlike_input(input) ? to_number(value) : value;\n\t\t\t\tsetter(value);\n\n\t\t\t\tawait tick();\n\n\t\t\t\tif (value !== getter()) {\n\t\t\t\t\tvar start = input.selectionStart;\n\t\t\t\t\tvar end = input.selectionEnd;\n\t\t\t\t\tinput.value = value ?? '';\n\n\t\t\t\t\t// Restore selection\n\t\t\t\t\tif (end !== null) {\n\t\t\t\t\t\tinput.selectionStart = start;\n\t\t\t\t\t\tinput.selectionEnd = Math.min(end, input.value.length);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\trender(() => {\n\t\t\t\tvar value = getter();\n\n\t\t\t\tif (is_numberlike_input(input) && value === to_number(input.value)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (input.type === 'date' && !value && !input.value) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (value !== input.value) {\n\t\t\t\t\tinput.value = value ?? '';\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn clear_event;\n\t\t}\n\t};\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {SetFunction | undefined} set_func\n * @returns {(node: HTMLInputElement) => void}\n */\nexport function bindChecked(maybe_tracked, set_func = undefined) {\n\tvar { getter, setter } = get_bind_get_set('bindChecked()', maybe_tracked, set_func);\n\n\treturn (input) => {\n\t\tvar clear_event = on(input, 'change', () => {\n\t\t\tsetter(input.checked);\n\t\t});\n\n\t\teffect(() => {\n\t\t\tvar value = getter();\n\t\t\tinput.checked = Boolean(value);\n\t\t});\n\n\t\treturn clear_event;\n\t};\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {SetFunction | undefined} set_func\n * @returns {(node: HTMLInputElement) => void}\n */\nexport function bindIndeterminate(maybe_tracked, set_func = undefined) {\n\tvar { getter, setter } = get_bind_get_set('bindIndeterminate()', maybe_tracked, set_func);\n\n\treturn (input) => {\n\t\tvar clear_event = on(input, 'change', () => {\n\t\t\tsetter(input.indeterminate);\n\t\t});\n\n\t\teffect(() => {\n\t\t\tvar value = getter();\n\t\t\tinput.indeterminate = Boolean(value);\n\t\t});\n\n\t\treturn clear_event;\n\t};\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {SetFunction | undefined} set_func\n * @returns {(node: HTMLInputElement) => void}\n */\nexport function bindGroup(maybe_tracked, set_func = undefined) {\n\tvar { getter, setter } = get_bind_get_set('bindGroup()', maybe_tracked, set_func);\n\n\treturn (input) => {\n\t\tvar is_checkbox = input.getAttribute('type') === 'checkbox';\n\n\t\tvar clear_event = on(input, 'change', () => {\n\t\t\tvar value = input.value;\n\t\t\tvar result;\n\n\t\t\tif (is_checkbox) {\n\t\t\t\t/** @type {Array<any>} */\n\t\t\t\tvar list = getter() || [];\n\n\t\t\t\tif (input.checked) {\n\t\t\t\t\tif (!list.includes(value)) {\n\t\t\t\t\t\tresult = [...list, value];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = list;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresult = list.filter((v) => v !== value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = input.value;\n\t\t\t}\n\n\t\t\tsetter(result);\n\t\t});\n\n\t\teffect(() => {\n\t\t\tvar value = getter();\n\t\t\tif (is_checkbox) {\n\t\t\t\tvalue = value || [];\n\t\t\t\tinput.checked = value.includes(input.value);\n\t\t\t} else {\n\t\t\t\tinput.checked = value === input.value;\n\t\t\t}\n\t\t});\n\n\t\treturn clear_event;\n\t};\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {'clientWidth' | 'clientHeight' | 'offsetWidth' | 'offsetHeight'} type\n * @param {SetFunction | undefined} set_func\n */\nfunction bind_element_size(maybe_tracked, type, set_func = undefined) {\n\tvar { setter } = get_bind_get_set(\n\t\t`bind${type.charAt(0).toUpperCase() + type.slice(1)}()`,\n\t\tmaybe_tracked,\n\t\tset_func,\n\t);\n\n\treturn (/** @type {HTMLElement} */ element) => {\n\t\tvar unsubscribe = resize_observer_border_box.observe(element, () => setter(element[type]));\n\n\t\teffect(() => {\n\t\t\tsetter(element[type]);\n\t\t\treturn unsubscribe;\n\t\t});\n\t};\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {SetFunction | undefined} set_func\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindClientWidth(maybe_tracked, set_func = undefined) {\n\treturn bind_element_size(maybe_tracked, 'clientWidth', set_func);\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {SetFunction | undefined} set_func\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindClientHeight(maybe_tracked, set_func = undefined) {\n\treturn bind_element_size(maybe_tracked, 'clientHeight', set_func);\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {SetFunction | undefined} set_func\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindOffsetWidth(maybe_tracked, set_func = undefined) {\n\treturn bind_element_size(maybe_tracked, 'offsetWidth', set_func);\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {SetFunction | undefined} set_func\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindOffsetHeight(maybe_tracked, set_func = undefined) {\n\treturn bind_element_size(maybe_tracked, 'offsetHeight', set_func);\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {'contentRect' | 'contentBoxSize' | 'borderBoxSize' | 'devicePixelContentBoxSize'} type\n * @param {SetFunction | undefined} set_func\n */\nfunction bind_element_rect(maybe_tracked, type, set_func = undefined) {\n\tvar { setter } = get_bind_get_set(\n\t\t`bind${type.charAt(0).toUpperCase() + type.slice(1)}()`,\n\t\tmaybe_tracked,\n\t\tset_func,\n\t);\n\n\tvar observer =\n\t\ttype === 'contentRect' || type === 'contentBoxSize'\n\t\t\t? resize_observer_content_box\n\t\t\t: type === 'borderBoxSize'\n\t\t\t\t? resize_observer_border_box\n\t\t\t\t: resize_observer_device_pixel_content_box;\n\n\treturn (/** @type {HTMLElement} */ element) => {\n\t\tvar unsubscribe = observer.observe(\n\t\t\telement,\n\t\t\t/** @param {any} entry */ (entry) => setter(entry[type]),\n\t\t);\n\n\t\teffect(() => unsubscribe);\n\t};\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {SetFunction | undefined} set_func\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindContentRect(maybe_tracked, set_func = undefined) {\n\treturn bind_element_rect(maybe_tracked, 'contentRect', set_func);\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {SetFunction | undefined} set_func\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindContentBoxSize(maybe_tracked, set_func = undefined) {\n\treturn bind_element_rect(maybe_tracked, 'contentBoxSize', set_func);\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {SetFunction | undefined} set_func\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindBorderBoxSize(maybe_tracked, set_func = undefined) {\n\treturn bind_element_rect(maybe_tracked, 'borderBoxSize', set_func);\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {SetFunction | undefined} set_func\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindDevicePixelContentBoxSize(maybe_tracked, set_func = undefined) {\n\treturn bind_element_rect(maybe_tracked, 'devicePixelContentBoxSize', set_func);\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {'innerHTML' | 'innerText' | 'textContent'} property\n * @param {SetFunction | undefined} set_func\n * @returns {(node: HTMLElement) => void}\n */\nexport function bind_content_editable(maybe_tracked, property, set_func = undefined) {\n\tvar { getter, setter } = get_bind_get_set(\n\t\t`bind${property.charAt(0).toUpperCase() + property.slice(1)}()`,\n\t\tmaybe_tracked,\n\t\tset_func,\n\t);\n\n\treturn (element) => {\n\t\tvar clear_event = on(element, 'input', () => {\n\t\t\tsetter(element[property]);\n\t\t});\n\n\t\trender(() => {\n\t\t\tvar value = getter();\n\t\t\tif (element[property] !== value) {\n\t\t\t\tif (value == null) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tvar non_null_value = element[property];\n\t\t\t\t\tsetter(non_null_value);\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\telement[property] = value + '';\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn clear_event;\n\t};\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {SetFunction | undefined} set_func\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindInnerHTML(maybe_tracked, set_func = undefined) {\n\treturn bind_content_editable(maybe_tracked, 'innerHTML', set_func);\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {SetFunction | undefined} set_func\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindInnerText(maybe_tracked, set_func = undefined) {\n\treturn bind_content_editable(maybe_tracked, 'innerText', set_func);\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {SetFunction | undefined} set_func\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindTextContent(maybe_tracked, set_func = undefined) {\n\treturn bind_content_editable(maybe_tracked, 'textContent', set_func);\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {SetFunction | undefined} set_func\n * @returns {(node: HTMLInputElement) => void}\n */\nexport function bindFiles(maybe_tracked, set_func = undefined) {\n\tvar { getter, setter } = get_bind_get_set('bindFiles()', maybe_tracked, set_func);\n\n\treturn (input) => {\n\t\tvar clear_event = on(input, 'change', () => {\n\t\t\tsetter(input.files);\n\t\t});\n\n\t\teffect(() => {\n\t\t\tvar value = getter();\n\n\t\t\tif (value !== input.files && value instanceof FileList) {\n\t\t\t\tinput.files = value;\n\t\t\t}\n\t\t});\n\n\t\treturn clear_event;\n\t};\n}\n\n/**\n * Syntactic sugar for binding a HTMLElement with {ref fn}\n * @param {unknown} maybe_tracked\n * @param {SetFunction | undefined} set_func\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindNode(maybe_tracked, set_func = undefined) {\n\tvar { setter } = get_bind_get_set('bindNode()', maybe_tracked, set_func);\n\n\t/** @param {HTMLElement} node */\n\treturn (node) => {\n\t\tsetter(node);\n\t};\n}\n",
    "/** @import { Block, CompatOptions } from '#client' */\n\nimport { destroy_block, root } from './internal/client/blocks.js';\nimport { handle_root_events } from './internal/client/events.js';\nimport { init_operations } from './internal/client/operations.js';\nimport { active_block } from './internal/client/runtime.js';\nimport { create_anchor } from './internal/client/utils.js';\nimport { remove_ssr_css } from './internal/client/css.js';\n\n// Re-export JSX runtime functions for jsxImportSource: \"ripple\"\nexport { jsx, jsxs, Fragment } from '../jsx-runtime.js';\n\n/**\n * @param {(anchor: Node, props: Record<string, any>, active_block: Block | null) => void} component\n * @param {{ props?: Record<string, any>, target: HTMLElement, compat?: CompatOptions }} options\n * @returns {() => void}\n */\nexport function mount(component, options) {\n\tinit_operations();\n\tremove_ssr_css();\n\n\tconst props = options.props || {};\n\tconst target = options.target;\n\tconst anchor = create_anchor();\n\n\t// Clear target content in case of SSR\n\tif (target.firstChild) {\n\t\ttarget.textContent = '';\n\t}\n\n\ttarget.append(anchor);\n\n\tconst cleanup_events = handle_root_events(target);\n\n\tconst _root = root(() => {\n\t\tcomponent(anchor, props, active_block);\n\t}, options.compat);\n\n\treturn () => {\n\t\tcleanup_events();\n\t\tdestroy_block(_root);\n\t};\n}\n\nexport { Context } from './internal/client/context.js';\n\nexport {\n\tflush_sync as flushSync,\n\ttrack,\n\ttrack_split as trackSplit,\n\tuntrack,\n\ttick,\n} from './internal/client/runtime.js';\n\nexport { TrackedArray } from './array.js';\n\nexport { TrackedObject } from './object.js';\n\nexport { TrackedSet } from './set.js';\n\nexport { TrackedMap } from './map.js';\n\nexport { TrackedDate } from './date.js';\n\nexport { TrackedURL } from './url.js';\n\nexport { TrackedURLSearchParams } from './url-search-params.js';\n\nexport { createSubscriber } from './create-subscriber.js';\n\nexport { MediaQuery } from './media-query.js';\n\nexport { user_effect as effect } from './internal/client/blocks.js';\n\nexport { Portal } from './internal/client/portal.js';\n\nexport { ref_prop as createRefKey, get, public_set as set } from './internal/client/runtime.js';\n\nexport { on } from './internal/client/events.js';\n\nexport {\n\tbindValue,\n\tbindChecked,\n\tbindGroup,\n\tbindClientWidth,\n\tbindClientHeight,\n\tbindContentRect,\n\tbindContentBoxSize,\n\tbindBorderBoxSize,\n\tbindDevicePixelContentBoxSize,\n\tbindFiles,\n\tbindIndeterminate,\n\tbindInnerHTML,\n\tbindInnerText,\n\tbindTextContent,\n\tbindNode,\n\tbindOffsetWidth,\n\tbindOffsetHeight,\n} from './internal/client/bindings.js';\n",
    "import type { Grid, Point } from \"./types\";\n\nconst wrapIndex = (size: number, value: number) => (value + size) % size;\n\nexport const getNeighbours = (grid: Grid, position: Point): number => {\n  const size = grid.length;\n  let count = 0;\n\n  for (let yOffset = -1; yOffset <= 1; yOffset += 1) {\n    for (let xOffset = -1; xOffset <= 1; xOffset += 1) {\n      if (yOffset === 0 && xOffset === 0) {\n        continue;\n      }\n\n      const y = wrapIndex(size, position.y + yOffset);\n      const x = wrapIndex(size, position.x + xOffset);\n\n      if (grid[y]?.[x]) {\n        count += 1;\n      }\n    }\n  }\n\n  return count;\n};\n\nexport const willLive = (isAlive: boolean, neighbours: number) =>\n  isAlive ? neighbours >= 2 && neighbours <= 3 : neighbours === 3;\n\nexport const nextState = (grid: Grid): Grid =>\n  grid.map((row, y) =>\n    row.map((cell, x) => willLive(cell, getNeighbours(grid, { y, x }))),\n  );\n",
    "import type { Grid, Point } from \"./types\";\n\nexport const createGrid = (size: number): Grid =>\n  Array.from({ length: size }, () =>\n    Array.from({ length: size }, () => false),\n  );\n\nexport const createRandomGrid = (size: number, density = 0.22): Grid =>\n  createGrid(size).map((row) => row.map(() => Math.random() < density));\n\nexport const toggleCell = (grid: Grid, point: Point): Grid =>\n  grid.map((row, y) =>\n    y === point.y\n      ? row.map((cell, x) => (x === point.x ? !cell : cell))\n      : row.slice(),\n  );\n",
    "import * as _$_ from 'ripple/internal/client';\n\nvar root = _$_.template(`<div class=\"min-h-screen px-4 pb-16 pt-8 sm:px-8 lg:px-12\"><header class=\"mx-auto mb-8 max-w-5xl\"><div class=\"inline-block border-3 border-black bg-[var(--neo-blue)] px-4 py-2 neo-shadow mb-4\"><p class=\"text-xs font-bold uppercase tracking-widest\">Ripple + Cellular Automata</p></div><h1 class=\"font-['Syne'] text-5xl font-extrabold uppercase tracking-tight sm:text-6xl lg:text-7xl\"> <br><span class=\"inline-block border-3 border-black bg-[var(--neo-pink)] px-3 -rotate-1\">Game of Life</span></h1><p class=\"mt-4 max-w-xl text-base font-medium leading-relaxed\">Seed a few cells, press play, and watch patterns ripple across the field.</p></header><main class=\"mx-auto grid max-w-5xl gap-6 lg:grid-cols-[300px_minmax(0,1fr)]\"><section><div class=\"flex items-baseline justify-between border-b-3 border-black pb-4 mb-4\"><h2 class=\"font-['Syne'] text-xl font-bold uppercase\">Controls</h2><span class=\"border-2 border-black bg-white px-2 py-1 text-xs font-bold\"> </span></div><div class=\"grid grid-cols-3 gap-3 mb-6\"><div><span class=\"block text-[10px] font-bold uppercase tracking-wider text-black/60\">Gen</span><span class=\"block text-2xl font-bold tabular-nums\"> </span></div><div><span class=\"block text-[10px] font-bold uppercase tracking-wider text-black/60\">Alive</span><span class=\"block text-2xl font-bold tabular-nums\"> </span></div><div><span class=\"block text-[10px] font-bold uppercase tracking-wider text-black/60\">FPS</span><span class=\"block text-2xl font-bold tabular-nums\"> </span></div></div><div class=\"grid gap-3\"><button> </button><div class=\"grid grid-cols-2 gap-3\"><button>Step</button><button>Random</button></div><button>Clear</button></div><div class=\"mt-6 border-3 border-black bg-white p-3 neo-shadow\"><p class=\"text-xs font-medium\"><span class=\"font-bold\">TIP:</span> </p></div></section><section class=\"border-3 border-black bg-white p-4 neo-shadow-lg\"><div class=\"flex flex-wrap items-center justify-between gap-3 border-b-3 border-black pb-3 mb-4\"><h2 class=\"font-['Syne'] text-xl font-bold uppercase\">Habitat</h2><div class=\"flex items-center gap-4 text-xs font-bold uppercase\"><span class=\"flex items-center gap-2\"><span class=\"h-4 w-4 border-2 border-black bg-[var(--neo-pink)]\"></span> </span><span class=\"flex items-center gap-2\"><span class=\"h-4 w-4 border-2 border-black bg-white\"></span> </span></div></div><div class=\"grid touch-none gap-0 border-3 border-black bg-black p-[1px] neo-inset\"></div></section></main><footer class=\"mx-auto mt-8 max-w-5xl\"><div class=\"inline-block border-3 border-black bg-black text-white px-4 py-2 neo-shadow\"><p class=\"text-xs font-bold uppercase tracking-wider\">Built with Ripple + Bun</p></div></footer></div>`, 1);\nvar root_1 = _$_.template(`<!>`, 1);\nvar root_2 = _$_.template(`<button></button>`, 0);\n\nimport { effect, track } from \"ripple\";\nimport { nextState } from \"./lib/game\";\nimport { createGrid, createRandomGrid, toggleCell } from \"./lib/utils\";\n\nconst DEFAULT_SIZE = 28;\nconst DENSITY = 0.24;\n\nexport function App(__anchor, _, __block) {\n\t_$_.push_component();\n\n\tvar fragment = root();\n\tvar div_2 = _$_.child_frag(fragment);\n\tvar header_1 = _$_.child(div_2);\n\tvar div_1 = _$_.child(header_1);\n\tvar h1_1 = _$_.sibling(div_1);\n\tvar text = _$_.child(h1_1);\n\tvar main_1 = _$_.sibling(header_1);\n\tvar section_1 = _$_.child(main_1);\n\tvar div_3 = _$_.child(section_1);\n\tvar h2_1 = _$_.child(div_3);\n\tvar span_1 = _$_.sibling(h2_1);\n\tvar text_1 = _$_.child(span_1);\n\tvar div_5 = _$_.sibling(div_3);\n\tvar div_4 = _$_.child(div_5);\n\tvar span_3 = _$_.child(div_4);\n\tvar span_2 = _$_.sibling(span_3);\n\tvar text_2 = _$_.child(span_2);\n\tvar div_6 = _$_.sibling(div_4);\n\tvar span_5 = _$_.child(div_6);\n\tvar span_4 = _$_.sibling(span_5);\n\tvar text_3 = _$_.child(span_4);\n\tvar div_7 = _$_.sibling(div_6);\n\tvar span_7 = _$_.child(div_7);\n\tvar span_6 = _$_.sibling(span_7);\n\tvar text_4 = _$_.child(span_6);\n\tvar div_8 = _$_.sibling(div_5);\n\tvar button_1 = _$_.child(div_8);\n\tvar text_5 = _$_.child(button_1);\n\tvar div_9 = _$_.sibling(button_1);\n\tvar button_2 = _$_.child(div_9);\n\tvar button_3 = _$_.sibling(button_2);\n\tvar button_4 = _$_.sibling(div_9);\n\tvar div_10 = _$_.sibling(div_8);\n\tvar p_1 = _$_.child(div_10);\n\tvar span_8 = _$_.child(p_1);\n\tvar text_6 = _$_.sibling(span_8);\n\tvar section_2 = _$_.sibling(section_1);\n\tvar div_12 = _$_.child(section_2);\n\tvar h2_2 = _$_.child(div_12);\n\tvar div_11 = _$_.sibling(h2_2);\n\tvar span_10 = _$_.child(div_11);\n\tvar span_9 = _$_.child(span_10);\n\tvar text_7 = _$_.sibling(span_9);\n\tvar span_12 = _$_.sibling(span_10);\n\tvar span_11 = _$_.child(span_12);\n\tvar text_8 = _$_.sibling(span_11);\n\tvar div_13 = _$_.sibling(div_12);\n\tconst size = DEFAULT_SIZE;\n\tlet grid = track(_$_.with_scope(__block, () => createRandomGrid(size, DENSITY)), void 0, void 0, __block);\n\tlet running = track(false, void 0, void 0, __block);\n\tlet generation = track(0, void 0, void 0, __block);\n\tlet fps = track(0, void 0, void 0, __block);\n\tlet living = track(() => _$_.with_scope(__block, () => _$_.get(grid).reduce((total, row) => total + _$_.with_scope(__block, () => row.filter(Boolean)).length, 0)), void 0, void 0, __block);\n\tconst buttonBase = \"inline-flex w-full items-center justify-center border-3 border-black px-4 py-3 text-sm font-bold uppercase tracking-wide neo-shadow-hover cursor-pointer\";\n\tconst panelSurface = \"border-3 border-black bg-[var(--neo-yellow)] p-6 neo-shadow-lg\";\n\tconst statSurface = \"border-3 border-black bg-white p-4 neo-shadow\";\n\tconst cellBase = \"aspect-square w-full border border-black bg-white transition-colors duration-75\";\n\tconst cellAlive = \"bg-[var(--neo-pink)] border-black\";\n\n\tconst stepForward = () => {\n\t\t_$_.set(grid, _$_.with_scope(__block, () => nextState(_$_.get(grid))));\n\t\t_$_.set(generation, _$_.get(generation) + 1);\n\t};\n\n\tconst toggleRunning = () => {\n\t\t_$_.set(running, !_$_.get(running));\n\t};\n\n\tconst handleClear = () => {\n\t\t_$_.set(running, false);\n\t\t_$_.set(generation, 0);\n\t\t_$_.set(grid, _$_.with_scope(__block, () => createGrid(size)));\n\t};\n\n\tconst handleRandom = () => {\n\t\t_$_.set(running, false);\n\t\t_$_.set(generation, 0);\n\t\t_$_.set(grid, _$_.with_scope(__block, () => createRandomGrid(size, DENSITY)));\n\t};\n\n\t_$_.with_scope(__block, () => effect(() => {\n\t\tif (!_$_.get(running)) {\n\t\t\t_$_.set(fps, 0);\n\n\t\t\treturn;\n\t\t}\n\n\t\tlet rafId = 0;\n\t\tlet frames = 0;\n\t\tlet fpsStamp = _$_.with_scope(__block, () => performance.now());\n\n\t\tconst loop = (now) => {\n\t\t\tframes += 1;\n\n\t\t\tif (now - fpsStamp >= 500) {\n\t\t\t\t_$_.set(fps, _$_.with_scope(__block, () => Math.round(frames * 1000 / (now - fpsStamp))));\n\t\t\t\tfpsStamp = now;\n\t\t\t\tframes = 0;\n\t\t\t}\n\n\t\t\t_$_.set(grid, _$_.with_scope(__block, () => nextState(_$_.get(grid))));\n\t\t\t_$_.set(generation, _$_.get(generation) + 1);\n\t\t\trafId = _$_.with_scope(__block, () => requestAnimationFrame(loop));\n\t\t};\n\n\t\trafId = _$_.with_scope(__block, () => requestAnimationFrame(loop));\n\n\t\treturn () => _$_.with_scope(__block, () => cancelAnimationFrame(rafId));\n\t}));\n\n\t{\n\t\t{\n\t\t\t_$_.set_class(section_1, panelSurface, void 0, true);\n\n\t\t\t{\n\t\t\t\t{\n\t\t\t\t\t_$_.set_class(div_4, statSurface, void 0, true);\n\t\t\t\t\t_$_.set_class(div_6, statSurface, void 0, true);\n\t\t\t\t\t_$_.set_class(div_7, statSurface, void 0, true);\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tbutton_1.__click = toggleRunning;\n\n\t\t\t\t\t{\n\t\t\t\t\t\tbutton_2.__click = stepForward;\n\n\t\t\t\t\t\t_$_.set_class(\n\t\t\t\t\t\t\tbutton_2,\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tbuttonBase,\n\t\t\t\t\t\t\t\t\"bg-[var(--neo-purple)] text-white hover:bg-purple-400\"\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tvoid 0,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbutton_3.__click = handleRandom;\n\t\t\t\t\t\t_$_.set_class(button_3, [buttonBase, \"bg-[var(--neo-blue)] hover:bg-teal-300\"], void 0, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tbutton_4.__click = handleClear;\n\t\t\t\t\t_$_.set_class(button_4, [buttonBase, \"bg-white hover:bg-gray-100\"], void 0, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t{\n\t\t\t\t_$_.set_style(div_13, { gridTemplateColumns: `repeat(${size}, minmax(0, 1fr))` }, void 0);\n\n\t\t\t\t{\n\t\t\t\t\t_$_.for(\n\t\t\t\t\t\tdiv_13,\n\t\t\t\t\t\t() => _$_.get(grid),\n\t\t\t\t\t\t(__anchor, row, y) => {\n\t\t\t\t\t\t\tvar fragment_1 = root_1();\n\t\t\t\t\t\t\tvar node = _$_.child_frag(fragment_1);\n\n\t\t\t\t\t\t\t_$_.for(\n\t\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\t\t() => row,\n\t\t\t\t\t\t\t\t(__anchor, cell, x) => {\n\t\t\t\t\t\t\t\t\tvar button_5 = root_2();\n\n\t\t\t\t\t\t\t\t\tbutton_5.__pointerdown = () => {\n\t\t\t\t\t\t\t\t\t\t_$_.set(grid, _$_.with_scope(__block, () => toggleCell(_$_.get(grid), { y: _$_.get(y), x: _$_.get(x) })));\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t_$_.event('PointerEnter', button_5, (event) => {\n\t\t\t\t\t\t\t\t\t\tif (event.buttons === 1) {\n\t\t\t\t\t\t\t\t\t\t\t_$_.set(grid, _$_.with_scope(__block, () => toggleCell(_$_.get(grid), { y: _$_.get(y), x: _$_.get(x) })));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t_$_.set_class(button_5, [cellBase, cell && cellAlive], void 0, true);\n\n\t\t\t\t\t\t\t\t\t_$_.render(() => {\n\t\t\t\t\t\t\t\t\t\t_$_.set_attribute(button_5, 'aria-label', `Cell ${_$_.get(y) + 1}, ${_$_.get(x) + 1}`);\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t_$_.append(__anchor, button_5);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t8\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t_$_.append(__anchor, fragment_1);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t12\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_$_.render(\n\t\t(__prev) => {\n\t\t\tvar __a = \"Conway's\";\n\n\t\t\tif (__prev.a !== __a) {\n\t\t\t\t_$_.set_text(text, __prev.a = __a);\n\t\t\t}\n\n\t\t\tvar __b = size + _$_.with_scope(__block, () => String(\"x\" + String(size)));\n\n\t\t\tif (__prev.b !== __b) {\n\t\t\t\t_$_.set_text(text_1, __prev.b = __b);\n\t\t\t}\n\n\t\t\tvar __c = _$_.get(generation);\n\n\t\t\tif (__prev.c !== __c) {\n\t\t\t\t_$_.set_text(text_2, __prev.c = __c);\n\t\t\t}\n\n\t\t\tvar __d = _$_.get(living);\n\n\t\t\tif (__prev.d !== __d) {\n\t\t\t\t_$_.set_text(text_3, __prev.d = __d);\n\t\t\t}\n\n\t\t\tvar __e = _$_.get(fps);\n\n\t\t\tif (__prev.e !== __e) {\n\t\t\t\t_$_.set_text(text_4, __prev.e = __e);\n\t\t\t}\n\n\t\t\tvar __f = _$_.get(running) ? \"Pause\" : \"Play\";\n\n\t\t\tif (__prev.f !== __f) {\n\t\t\t\t_$_.set_text(text_5, __prev.f = __f);\n\t\t\t}\n\n\t\t\tvar __g = [\n\t\t\t\tbuttonBase,\n\t\t\t\t_$_.get(running)\n\t\t\t\t\t? \"bg-[var(--neo-orange)] hover:bg-orange-400\"\n\t\t\t\t\t: \"bg-[var(--neo-green)] hover:bg-lime-400\"\n\t\t\t];\n\n\t\t\tif (__prev.g !== __g) {\n\t\t\t\t_$_.set_class(button_1, __prev.g = __g, void 0, true);\n\t\t\t}\n\n\t\t\tvar __h = \" hold and drag to paint cells\";\n\n\t\t\tif (__prev.h !== __h) {\n\t\t\t\t_$_.set_text(text_6, __prev.h = __h);\n\t\t\t}\n\n\t\t\tvar __i = \"Alive\";\n\n\t\t\tif (__prev.i !== __i) {\n\t\t\t\t_$_.set_text(text_7, __prev.i = __i);\n\t\t\t}\n\n\t\t\tvar __j = \"Dead\";\n\n\t\t\tif (__prev.j !== __j) {\n\t\t\t\t_$_.set_text(text_8, __prev.j = __j);\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\ta: ' ',\n\t\t\tb: ' ',\n\t\t\tc: ' ',\n\t\t\td: ' ',\n\t\t\te: ' ',\n\t\t\tf: ' ',\n\t\t\tg: Symbol(),\n\t\t\th: ' ',\n\t\t\ti: ' ',\n\t\t\tj: ' '\n\t\t}\n\t);\n\n\t_$_.append(__anchor, fragment);\n\t_$_.pop_component();\n}\n\n_$_.delegate(['click', 'pointerdown']);",
    "import { mount } from \"ripple\";\nimport { App } from \"./App.compiled.js\";\n\nconst target = document.getElementById(\"app\");\n\nif (!target) {\n  throw new Error(\"Missing #app element\");\n}\n\nmount(App, { target });\n"
  ],
  "mappings": "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",
  "debugId": "508CA5C7281A95C264756E2164756E21",
  "names": []
}