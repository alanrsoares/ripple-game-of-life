import { track, trackSplit, effect } from "ripple";

interface HabitatProps {
  grid: boolean[][];
  size: number;
  renderMode: "canvas" | "dom";
  onSetCell: (y: number, x: number, value: boolean) => void;
}

export component Habitat(props: HabitatProps) {
  const [grid, size, renderMode] = trackSplit(props, ["grid", "size", "renderMode"]);
  let canvasRef = track(null as HTMLCanvasElement | null);

  // Paint state shared
  let paintMode = null as boolean | null;
  const paintedCells = new Set();

  // --- Canvas Logic ---
  const getCellFromEvent = (e: PointerEvent) => {
    const canvas = @canvasRef;
    if (!canvas) return { row: 0, col: 0 };
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const cellSize = rect.width / @size;
    
    const col = Math.floor(x / cellSize);
    const row = Math.floor(y / cellSize);
    
    const clampedCol = Math.min(Math.max(0, col), @size - 1);
    const clampedRow = Math.min(Math.max(0, row), @size - 1);
    
    return { row: clampedRow, col: clampedCol };
  };

  const startPaintCanvas = (e: PointerEvent) => {
    const { row, col } = getCellFromEvent(e);
    const currentGrid = @grid;
    if (!currentGrid[row]) return;
    
    const currentState = currentGrid[row][col];
    paintMode = !currentState;
    paintedCells.clear();
    paintedCells.add(`${row},${col}`);
    props.onSetCell(row, col, paintMode);
    
    @canvasRef?.setPointerCapture(e.pointerId);
  };

  const continuePaintCanvas = (e: PointerEvent) => {
    if (paintMode === null) return;
    const { row, col } = getCellFromEvent(e);
    const key = `${row},${col}`;
    if (paintedCells.has(key)) return;
    
    paintedCells.add(key);
    props.onSetCell(row, col, paintMode);
  };

  const endPaintCanvas = (e: PointerEvent) => {
    paintMode = null;
    paintedCells.clear();
    @canvasRef?.releasePointerCapture(e.pointerId);
  };

  const setCanvasRef = (el: HTMLCanvasElement) => {
     @canvasRef = el;
  };

  const draw = () => {
    const canvas = @canvasRef;
    if (!canvas) return;
    
    const ctx = canvas.getContext("2d", { alpha: false });
    if (!ctx) return;

    const width = canvas.width;
    const height = canvas.height;
    const gridSize = @size;
    const currentGrid = @grid;
    const cellSize = width / gridSize;

    // 1. Fill background (Dead state: White)
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, width, height);

    // 2. Draw Grid Lines manually using fillRect for crisp lines
    // DOM border is border-black/20 (1px)
    // Canvas is scaled by DPR, so 2 physical pixels ~ 1 CSS pixel on Retina, or 2px on standard.
    // User requested "double the inner border stroke".
    ctx.fillStyle = "rgba(0,0,0,0.2)";
    
    // Vertical lines
    for (let x = 1; x < gridSize; x++) {
      const xPos = Math.floor(x * cellSize) - 1;
      ctx.fillRect(xPos, 0, 2, height);
    }
    // Horizontal lines
    for (let y = 1; y < gridSize; y++) {
      const yPos = Math.floor(y * cellSize) - 1;
      ctx.fillRect(0, yPos, width, 2);
    }

    // 3. Fill Alive Cells
    ctx.fillStyle = "#ff6b9d";
    
    for (let y = 0; y < gridSize; y++) {
      const row = currentGrid[y];
      if (!row) continue;
      for (let x = 0; x < gridSize; x++) {
        if (row[x]) {
          const xPos = Math.floor(x * cellSize);
          const yPos = Math.floor(y * cellSize);
          const nextX = Math.floor((x + 1) * cellSize);
          const nextY = Math.floor((y + 1) * cellSize);
          
          ctx.fillRect(xPos, yPos, nextX - xPos, nextY - yPos);
        }
      }
    }
  };

  effect(() => {
    // 1. Cleanup/Reset if not in canvas mode
    if (@renderMode !== "canvas") {
      if (@canvasRef) @canvasRef = null;
      return;
    }

    let canvas = @canvasRef;
    
    // 2. Check validity and Fallback
    const isDetached = canvas && !document.body.contains(canvas);
    
    if (!canvas || isDetached) {
        canvas = document.getElementById("habitat-canvas") as HTMLCanvasElement;
        if (canvas) {
             @canvasRef = canvas;
        } else {
             // 3. Retry if DOM not ready yet
             const timer = setTimeout(() => {
                 const el = document.getElementById("habitat-canvas") as HTMLCanvasElement;
                 if (el) @canvasRef = el;
             }, 20);
             return () => clearTimeout(timer);
        }
    }
    
    // If we still don't have a valid canvas, stop here (retry will handle it)
    if (!canvas) return;

    const resizeObserver = new ResizeObserver(() => {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        draw();
    });

    resizeObserver.observe(canvas);
    
    // Force initial draw
    draw();
    
    return () => resizeObserver.disconnect();
  });

  effect(() => {
     if (@renderMode === "canvas" && @canvasRef) {
       draw();
     }
  });

  // --- DOM Logic ---
  const startPaintDOM = (y, x) => {
    const currentGrid = @grid;
    const currentState = currentGrid[y][x];
    paintMode = !currentState;
    paintedCells.clear();
    paintedCells.add(`${y},${x}`);
    props.onSetCell(y, x, paintMode);
  };

  const continuePaintDOM = (y, x) => {
    if (paintMode === null) return;
    const key = `${y},${x}`;
    if (paintedCells.has(key)) return;
    paintedCells.add(key);
    props.onSetCell(y, x, paintMode);
  };

  const endPaintDOM = () => {
    paintMode = null;
    paintedCells.clear();
  };

  effect(() => {
    const handleUp = () => endPaintDOM();
    window.addEventListener("pointerup", handleUp);
    window.addEventListener("pointercancel", handleUp);
    return () => {
      window.removeEventListener("pointerup", handleUp);
      window.removeEventListener("pointercancel", handleUp);
    };
  });

  const cellBase =
    "aspect-square w-full border border-black/20 transition-colors duration-75 hover:border-black";
  const cellAlive = "!bg-[var(--neo-pink)] !border-[var(--neo-pink)]";
  const cellDead = "bg-white";

  <section class="border-3 border-black bg-white p-4 neo-shadow-lg flex flex-col">
    <div class="flex flex-wrap items-center justify-between gap-3 border-b-2 border-black pb-3 mb-4">
      <h2 class="font-['Syne'] text-lg font-bold uppercase">{"Habitat"}</h2>
      <div class="flex items-center gap-3 text-[10px] font-bold uppercase tracking-wide">
        <span class="flex items-center gap-1.5">
          <span class="h-3 w-3 border border-black/20 bg-[var(--neo-pink)]"></span>
          {"Alive"}
        </span>
        <span class="flex items-center gap-1.5">
          <span class="h-3 w-3 border border-black/20 bg-white"></span>
          {"Dead"}
        </span>
      </div>
    </div>

    if (@renderMode === "canvas") {
      <canvas
        id="habitat-canvas"
        class="border-2 border-black bg-black/10 flex-1 w-full aspect-square max-w-[min(100%,640px)] self-center hover:cursor-pointer touch-none"
        ref={setCanvasRef}
        onPointerDown={startPaintCanvas}
        onPointerMove={continuePaintCanvas}
        onPointerUp={endPaintCanvas}
        onPointerCancel={endPaintCanvas}
        aria-label="Game of Life Grid (Canvas)"
        role="grid"
      ></canvas>
    } else {
      <div
        class="grid touch-none gap-0 border-2 border-black bg-black/10 flex-1 w-full aspect-square max-w-[min(100%,640px)] self-center hover:cursor-pointer"
        style={{ gridTemplateColumns: `repeat(${@size}, minmax(0, 1fr))`, contain: "strict" }}
        onPointerUp={endPaintDOM}
      >
        for (const row of @grid; index y; key y) {
          for (const cell of row; index x; key x) {
            <button
              class={[cellBase, cell ? cellAlive : cellDead]}
              onPointerDown={() => startPaintDOM(y, x)}
              onPointerEnter={(event) => {
                if (event.buttons === 1) {
                  continuePaintDOM(y, x);
                }
              }}
              aria-label={`Cell ${y + 1}, ${x + 1}`}
            ></button>
          }
        }
      </div>
    }

    <p class="mt-3 text-[10px] text-black/40 text-center font-medium uppercase tracking-wider">
      {"Built with Ripple + Bun"}
    </p>
  </section>
}
